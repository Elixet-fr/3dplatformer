<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Platformer - Pleasant Audio & Easier Level</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: Arial, Helvetica, sans-serif; background: #87ceeb; }
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      color: white;
      z-index: 2;
      user-select: none;
      font-size: 14px;
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
    }
    .panel {
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 8px;
      color: white;
      max-width: 320px;
      text-align: center;
    }
    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: none;
      background: #222;
      color: white;
      cursor: pointer;
      font-size: 14px;
      margin-top: 12px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    WASD / Arrow keys: move &nbsp;&nbsp; Space: jump &nbsp;&nbsp; **Shift: dash** &nbsp;&nbsp; R: respawn<br>
    Mouse drag: rotate camera<br>
    Wall jump: jump again while touching a wall in air.
  </div>
  <div id="overlay">
    <div class="panel" id="startPanel">
      <h2 style="margin:0 0 8px 0">3D Platformer â€” Pleasant Edition</h2>
      <div>Use WASD to move. Use **Shift** to dash. Enjoy the smoother sounds and easier level!</div>
      <button id="startBtn">Start</button>
    </div>
    <div class="panel" id="winPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">You win! ðŸŽ‰</h2>
      <button id="restartBtn">Play again</button>
    </div>
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0; color:#f33;">Game Over</h2>
      <div>You hit a spike! Try again.</div>
      <button id="gameOverRestartBtn">Restart</button>
    </div>
  </div>
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let player, platforms = [], spikes = [], walls = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;

    // --- Physics & Wall Jump Logic ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.1;
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.15;
    let jumpInputBufferTimer = 0;
    
    // --- Dash Logic ---
    let isDashing = false;
    const DASH_SPEED = 20;
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    // Decreased cooldown for easier gameplay
    const DASH_COOLDOWN = 0.7; 
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3();
    const defaultPlayerColor = 0xff8c00;
    const dashPlayerColor = 0x00ffff;
    // ------------------
    
    // --- Gameplay Adjustments for Easier Play ---
    // Increased Jump Power
    const JUMP_POWER = 7.0; // was 6.0
    const WALL_JUMP_POWER = 8.5; // was 7.5

    // Orbit camera params
    let orbitRadius = 12;
    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let isDragging = false;
    let dragStart = {x: 0, y: 0};
    let dragSensitivity = 0.005;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.1;

    // Audio context and music
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let backgroundMusic = null;

    function playMusic() {
      if (!audioCtx || backgroundMusic) return;

      const tempo = 120; // BPM
      const quarterNote = 60 / tempo;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.08, audioCtx.currentTime); // Low volume background music
      gain.connect(audioCtx.destination);

      let sequence = [
        { note: 440, duration: quarterNote }, // A4
        { note: 554.37, duration: quarterNote }, // C#5
        { note: 659.25, duration: quarterNote }, // E5
        { note: 880, duration: quarterNote * 2 }, // A5
        { note: 0, duration: quarterNote } // Rest
      ];
      
      let time = audioCtx.currentTime;

      function playSequence() {
        for (let i = 0; i < sequence.length; i++) {
          let seq = sequence[i];
          if (seq.note > 0) {
            let osc = audioCtx.createOscillator();
            osc.type = 'sine'; // Use sine wave for smooth music
            osc.frequency.setValueAtTime(seq.note, time);
            osc.connect(gain);
            osc.start(time);
            osc.stop(time + seq.duration * 0.9); // Slight gap between notes
          }
          time += seq.duration;
        }
        // Loop the sequence
        backgroundMusic = setTimeout(playSequence, (time - audioCtx.currentTime) * 1000);
      }
      playSequence();
    }

    function playSound(type) {
      if(!audioCtx) return;

      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gainNode = audioCtx.createGain();
      
      // Use a low-pass filter to smooth the sound and make it less sharp
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(2000, now); 

      osc.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      switch(type) {
        case 'jump':
          osc.type = 'sine'; // Smoother waveform
          osc.frequency.setValueAtTime(400, now); // Lower frequency
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.2, now + 0.04);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.18);
          break;
        case 'walljump':
          osc.type = 'triangle'; // Smoother than sawtooth
          osc.frequency.setValueAtTime(600, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.25, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.25);
          break;
        case 'dash':
          osc.type = 'square';
          osc.frequency.setValueAtTime(800, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
          break;
        case 'win':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(700, now); 
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.4, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
          break;
        case 'gameover':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(150, now); // Very low frequency
          gainNode.gain.setValueAtTime(0.4, now);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
          break;
      }

      osc.start(now);
      osc.stop(now + 0.5);
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas-holder').appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 50, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(10, 20, 10);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024,1024);
      scene.add(dir);

      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color:defaultPlayerColor});
      player = new THREE.Mesh(geom, mat);
      player.castShadow = true;
      player.receiveShadow = true;
      player.position.set(0,2,0);
      scene.add(player);

      // Base ground platform
      addPlatform(0, -1, 0, 20, 1, 20, 0x556b2f);

      // Platform params
      const platformWidth = 5; // Increased size
      const platformHeight = 0.5;
      let zPos = -2;
      let yPos = 0;

      // Spike geometry - pyramid
      const spikeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
      const spikeMaterial = new THREE.MeshStandardMaterial({color: 0x666666});

      // Wall geometry
      const wallMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
      const tallWallGeometry = new THREE.BoxGeometry(0.5, 8, 8); // Wider for easier wall jump

      // --- Level Design (Easier version) ---

      // 1. Initial Jump Test (Gap decreased)
      zPos += 4 + 1.5; // Gap reduced from 3 to 1.5
      addPlatform(0, yPos, zPos, platformWidth, platformHeight, 5, 0x8b4513);
      zPos += 5 + 1;

      // 2. Climbing Wall 1 (Easier jump from wider platform)
      yPos += 1.2; // Smaller height difference
      let plat1 = addPlatform(-5, yPos, zPos, 4, platformHeight, 5, 0x8b4513);
      
      let tallLeftWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallLeftWall.position.set(plat1.position.x - 1.5, plat1.position.y + 4, plat1.position.z);
      scene.add(tallLeftWall);
      walls.push(tallLeftWall);

      let tallRightWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallRightWall.position.set(plat1.position.x - 3.5, plat1.position.y + 4, plat1.position.z);
      scene.add(tallRightWall);
      walls.push(tallRightWall);
      
      // Dash jump target (closer)
      zPos += 5 + 2; // Reduced Z distance
      yPos += 2.5; // Reduced Y distance
      addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
      
      // 3. Low Ceiling Dash Section (Wider gap, less risky)
      yPos += 1;
      zPos += 5 + 1;
      let lowPlat = addPlatform(10, yPos, zPos, 6, platformHeight, 3, 0x8b4513);

      // Low ceiling above the platform is higher
      addPlatform(10, yPos + 1.5, zPos, 6, 0.2, 3, 0x777777); 

      yPos += 0.5;
      zPos += 5;
      addPlatform(10, yPos, zPos, 5, platformHeight, 5, 0x8b4513);

      // 4. Moving Platform Challenge with Spike (Slower and smaller amplitude)
      yPos += 1;
      zPos += 5 + 2;
      let movingPlat = addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x1e90ff);
      movingPlat.userData.moving = {amplitude:4, speed:0.8, axis:'x', base: movingPlat.position.x}; // Slower and less movement

      // Spike on moving platform
      let spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
      spike.castShadow = true;
      spike.receiveShadow = true;
      spike.position.set(movingPlat.position.x, movingPlat.position.y + platformHeight/2 + 0.5, movingPlat.position.z);
      scene.add(spike);
      spikes.push({mesh: spike, platform: movingPlat});

      // 5. Final Climb Wall & Win Platform
      yPos += 2;
      zPos += 7;
      let finalPlat = addPlatform(0, yPos, zPos, 5, platformHeight, 5, 0x8b4513);

      let finalWallLeft = new THREE.Mesh(tallWallGeometry, wallMaterial);
      finalWallLeft.position.set(finalPlat.position.x - 1.5, finalPlat.position.y + 4, finalPlat.position.z);
      scene.add(finalWallLeft);
      walls.push(finalWallLeft);

      let finalWallRight = new THREE.Mesh(tallWallGeometry, wallMaterial);
      finalWallRight.position.set(finalPlat.position.x + 1.5, finalPlat.position.y + 4, finalPlat.position.z);
      scene.add(finalWallRight);
      walls.push(finalWallRight);
      
      // Final glowing win platform is closer
      yPos += 3; // Smaller final height
      zPos += 5;
      const winP = addPlatform(5, yPos, zPos, 6, 0.5, 6, 0xffff00);
      winP.userData.win = true;


      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(e.code === 'Space' || e.code === 'Numpad0'){
          jumpInputBufferTimer = JUMP_INPUT_BUFFER_TIME;
        }
        if(e.code === 'ShiftLeft' && dashCooldownTimer <= 0 && !isDashing){
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;
            
            let angle = orbitAngleY;
            let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
            let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
            
            dashDirection.set(0,0,0);
            if(dirX !== 0 || dirZ !== 0) {
                dashDirection.addScaledVector(forward, dirZ);
                dashDirection.addScaledVector(right, dirX);
                dashDirection.normalize();
            } else {
                dashDirection.copy(forward);
            }

            isDashing = true;
            dashTimer = DASH_DURATION;
            player.material.color.setHex(dashPlayerColor);
            playSound('dash');
            
            velocity.y = Math.min(velocity.y, 0.5); 
        }
      });
      window.addEventListener('keyup', e => keys[e.code] = false);

      renderer.domElement.addEventListener('mousedown', onMouseDown);
      window.addEventListener('mouseup', onMouseUp);
      window.addEventListener('mousemove', onMouseMove);
    }

    function addPlatform(x,y,z,w,h,d,color) {
      const g = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.MeshStandardMaterial({color: color});
      const mesh = new THREE.Mesh(g,m);
      mesh.receiveShadow = true;
      mesh.position.set(x,y,z);
      mesh.userData.size = {x:w,y:h,z:d};
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) <= (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) <= (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) <= (aSize.z + bSize.z);
    }

    function handleJump(isWallJump, wallDir) {
        if(isWallJump) {
            velocity.y = WALL_JUMP_POWER; // Easier jump
            velocity.x = -8 * wallDir;
            playSound('walljump');
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
        } else {
            velocity.y = JUMP_POWER; // Easier jump
            playSound('jump');
        }
        onGround = false;
        jumpInputBufferTimer = 0;
    }

    function physics(delta) {
      if(gameOver || win) return;

      // Update timers
      if (!canWallJump && !onGround) {
        wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
      }
      jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
      dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);

      // Handle Dash Logic 
      if(isDashing) {
          dashTimer -= delta;
          if(dashTimer <= 0) {
              isDashing = false;
              dashCooldownTimer = DASH_COOLDOWN;
              player.material.color.setHex(defaultPlayerColor);
              velocity.x *= 0.5; 
              velocity.z *= 0.5;
          } else {
              player.position.addScaledVector(dashDirection, DASH_SPEED * delta);
              onGround = false;
              return; 
          }
      }

      let isTouchingWall = false;
      let currentWallDir = 0;

      // 1. Horizontal Movement 
      let dirX = 0, dirZ = 0;
      if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
      if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
      if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
      if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

      const speed = 6;
      if(dirX !== 0 || dirZ !== 0) {
        let angle = orbitAngleY;
        let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
        let moveDir = new THREE.Vector3();
        moveDir.addScaledVector(forward, dirZ);
        moveDir.addScaledVector(right, dirX);
        moveDir.normalize();
        player.position.addScaledVector(moveDir, speed * delta);
      }
      
      // 2. Wall detection for wall jump
      const pPos = player.position.clone();
      const half = {x:0.5,y:0.5,z:0.5};

      for(let w of walls){
        const wPos = w.position;
        const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
        if(aabbIntersect(pPos, half, wPos, wSize)){
          let diffX = pPos.x - wPos.x;
          if(Math.abs(diffX) > 0.01){
            isTouchingWall = true;
            currentWallDir = diffX > 0 ? 1 : -1;
            break;
          }
        }
      }

      if (isTouchingWall && !onGround) {
        canWallJump = true;
        wallJumpDirection = currentWallDir;
        wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
        
        // Wall Slide
        if (velocity.y < 0) {
            velocity.y = Math.max(velocity.y, -1.5);
        }
      } else if (!isTouchingWall && canWallJump) {
          canWallJump = false;
      } else if (onGround) {
          canWallJump = false;
          wallJumpCoyoteTimer = 0;
      }
      
      // 3. Jump Execution
      const isJumpPressed = (keys['Space'] || keys['Numpad0']);
      const canJump = onGround && isJumpPressed;
      const canWallJumpNow = isTouchingWall && jumpInputBufferTimer > 0;
      const canCoyoteJump = wallJumpCoyoteTimer > 0 && isJumpPressed && !onGround && !isTouchingWall;

      if(canJump){
        handleJump(false, 0);
      } else if(canWallJumpNow){
        handleJump(true, currentWallDir);
      } else if(canCoyoteJump){
        handleJump(true, wallJumpDirection); 
      }

      // Apply Gravity
      velocity.y -= 9.8 * delta;

      // Apply velocity X/Z (from wall jump or previous dash)
      player.position.x += velocity.x * delta;
      velocity.x *= 0.8; 
      player.position.z += velocity.z * delta; 
      velocity.z *= 0.8;

      player.position.y += velocity.y * delta;

      onGround = false;

      // 4. Platform Collision
      for(let pl of platforms) {
        if(pl.userData.moving){
          const t = performance.now()/1000;
          const m = pl.userData.moving;
          if(m.axis === 'x') pl.position.x = m.base + Math.sin(t*m.speed) * m.amplitude;
          else pl.position.z = m.base + Math.sin(t*m.speed) * m.amplitude;
        }
        const size = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
        if(aabbIntersect(pPos, half, pl.position, size)) {
          const playerBottom = player.position.y - 0.5;
          const plTop = pl.position.y + size.y;
          const penetration = plTop - playerBottom;
          if(velocity.y <= 0 && penetration > 0 && Math.abs(player.position.x - pl.position.x) < (size.x+half.x) && Math.abs(player.position.z - pl.position.z) < (size.z+half.z)){
            player.position.y += penetration + 0.001;
            velocity.y = 0;
            onGround = true;
            velocity.x = 0;
            velocity.z = 0;

            if(pl.userData.moving){
              player.position.x += (pl.position.x - (pl.userData._lastX ?? pl.position.x));
              player.position.z += (pl.position.z - (pl.userData._lastZ ?? pl.position.z));
            }

            if(pl.userData.win && !win){
              win = true;
              playSound('win');
              // Clear music loop on win
              if(backgroundMusic) clearTimeout(backgroundMusic);
              showWin();
            }
            
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
            dashCooldownTimer = 0; 
          }
          pl.userData._lastX = pl.position.x;
          pl.userData._lastZ = pl.position.z;
        }
      }

      // 5. Collide with walls
      for(let w of walls){
        const wPos = w.position;
        const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
        if(aabbIntersect(player.position, half, wPos, wSize)){
          let diffX = player.position.x - wPos.x;
          let diffZ = player.position.z - wPos.z;
          
          if(Math.abs(diffX) > Math.abs(diffZ)) {
              if(diffX > 0){
                player.position.x = wPos.x + wSize.x + 0.5 + 0.01;
                velocity.x = Math.max(velocity.x, 0);
              } else {
                player.position.x = wPos.x - wSize.x - 0.5 - 0.01;
                velocity.x = Math.min(velocity.x, 0);
              }
          } else {
              if(diffZ > 0){
                player.position.z = wPos.z + wSize.z + 0.5 + 0.01;
                velocity.z = Math.max(velocity.z, 0);
              } else {
                player.position.z = wPos.z - wSize.z - 0.5 - 0.01;
                velocity.z = Math.min(velocity.z, 0);
              }
          }
        }
      }

      // 6. Check spikes collision (game over)
      for(let s of spikes){
        const sp = s.mesh.position;
        if(player.position.distanceTo(sp) < 0.7){
          triggerGameOver();
          break;
        }
      }

      // Keep player above the floor plane
      if(player.position.y < -5){
        triggerGameOver();
      }
    }

    function triggerGameOver() {
      if(gameOver) return;
      gameOver = true;
      playSound('gameover');
      // Clear music loop on game over
      if(backgroundMusic) clearTimeout(backgroundMusic);
      document.getElementById('gameOverPanel').style.display = '';
      document.getElementById('overlay').style.display = '';
    }

    function updateCamera() {
      cameraTarget.x = THREE.MathUtils.lerp(cameraTarget.x, player.position.x, CAMERA_SMOOTHING);
      cameraTarget.y = THREE.MathUtils.lerp(cameraTarget.y, player.position.y + 0.5, CAMERA_SMOOTHING);
      cameraTarget.z = THREE.MathUtils.lerp(cameraTarget.z, player.position.z, CAMERA_SMOOTHING);
      
      orbitAngleX = Math.min(Math.max(0.1, orbitAngleX), Math.PI/2 - 0.1);
      const x = cameraTarget.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
      const y = cameraTarget.y + orbitRadius * Math.sin(orbitAngleX);
      const z = cameraTarget.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
      camera.position.set(x, y, z);
      camera.lookAt(cameraTarget);
    }

    function animate() {
      const delta = Math.min(0.05, clock.getDelta());
      physics(delta);
      updateCamera();
      renderer.render(scene, camera);
      if(!gameOver && !win) requestAnimationFrame(animate);
    }

    function respawn() {
      player.position.set(0, 2, 0);
      velocity.set(0,0,0);
      win = false;
      gameOver = false;
      canWallJump = false;
      wallJumpDirection = 0;
      wallJumpCoyoteTimer = 0;
      jumpInputBufferTimer = 0;
      isDashing = false;
      dashCooldownTimer = 0;
      player.material.color.setHex(defaultPlayerColor);
      document.getElementById('winPanel').style.display = 'none';
      document.getElementById('gameOverPanel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      clock.start();
      playMusic();
      animate();
    }

    function showWin() {
      document.getElementById('startPanel').style.display = 'none';
      const winPanel = document.getElementById('winPanel');
      winPanel.style.display = '';
      document.getElementById('overlay').style.display = '';
    }

    function onMouseDown(e) {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onMouseMove(e) {
      if(!isDragging) return;
      let deltaX = e.clientX - dragStart.x;
      let deltaY = e.clientY - dragStart.y;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      orbitAngleY -= deltaX * dragSensitivity;
      orbitAngleX -= deltaY * dragSensitivity;
    }

    window.addEventListener('DOMContentLoaded', () => {
      audioCtx = new AudioContext();
      init();
      cameraTarget.copy(player.position);
      cameraTarget.y += 0.5;

      document.getElementById('startBtn').addEventListener('click', () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        document.getElementById('overlay').style.display = 'none';
        clock.start();
        playMusic();
        animate();
      });
      document.getElementById('restartBtn').addEventListener('click', () => location.reload());
      document.getElementById('gameOverRestartBtn').addEventListener('click', () => {
        document.getElementById('gameOverPanel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        respawn();
      });
      window.addEventListener('keydown', e => {
        if(e.code === 'KeyR') respawn();
      });
    });
  </script>
</body>
</html>      border-radius: 6px;
      border: none;
      background: #222;
      color: white;
      cursor: pointer;
      font-size: 14px;
      margin-top: 12px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    WASD / Arrow keys: move &nbsp;&nbsp; Space: jump &nbsp;&nbsp; **Shift: dash** &nbsp;&nbsp; R: respawn<br>
    Mouse drag: rotate camera<br>
    Wall jump: jump again while touching a wall in air.
  </div>
  <div id="overlay">
    <div class="panel" id="startPanel">
      <h2 style="margin:0 0 8px 0">3D Platformer â€” Dash & Tall Walls</h2>
      <div>Use WASD to move. Use **Shift** to dash quickly! Use wall jumps and dashes to reach high and distant places.</div>
      <button id="startBtn">Start</button>
    </div>
    <div class="panel" id="winPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">You win! ðŸŽ‰</h2>
      <button id="restartBtn">Play again</button>
    </div>
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0; color:#f33;">Game Over</h2>
      <div>You hit a spike! Try again.</div>
      <button id="gameOverRestartBtn">Restart</button>
    </div>
  </div>
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    let scene, camera, renderer;
    let player, platforms = [], spikes = [], walls = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;

    // --- Physics & Wall Jump Logic ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.1;
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.15;
    let jumpInputBufferTimer = 0;
    
    // --- Dash Logic ---
    let isDashing = false;
    const DASH_SPEED = 20; // High speed for quick burst
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    const DASH_COOLDOWN = 1.0;
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3(); // Store direction player was moving when dash initiated
    const defaultPlayerColor = 0xff8c00;
    const dashPlayerColor = 0x00ffff; // Cyan color for dash feedback
    // ------------------

    // Orbit camera params
    let orbitRadius = 12;
    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let isDragging = false;
    let dragStart = {x: 0, y: 0};
    let dragSensitivity = 0.005;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.1;

    // Audio context for sounds
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function playSound(type) {
      if(!audioCtx) return;

      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      switch(type) {
        case 'jump':
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(600, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.15, now + 0.03);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
          break;
        case 'walljump':
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(800, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.2, now + 0.04);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
          break;
        case 'dash': // New dash sound
          osc.type = 'square';
          osc.frequency.setValueAtTime(1000, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
          break;
        case 'win':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(880, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
          break;
        case 'gameover':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(200, now);
          gainNode.gain.setValueAtTime(0.3, now);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
          break;
      }

      osc.start(now);
      osc.stop(now + 0.5);
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas-holder').appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 50, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(10, 20, 10);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024,1024);
      scene.add(dir);

      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color:defaultPlayerColor});
      player = new THREE.Mesh(geom, mat);
      player.castShadow = true;
      player.receiveShadow = true;
      player.position.set(0,2,0);
      scene.add(player);

      // Base ground platform
      addPlatform(0, -1, 0, 20, 1, 20, 0x556b2f);

      // Platform params
      const platformWidth = 4;
      const platformDepth = 4;
      const platformHeight = 0.5;
      let zPos = -2;
      let yPos = 0;

      // Spike geometry - pyramid
      const spikeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
      const spikeMaterial = new THREE.MeshStandardMaterial({color: 0x666666});

      // Wall geometry (thin tall walls)
      const wallMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
      const wallGeometry = new THREE.BoxGeometry(0.5, 4, 6);

      // Really tall walls for climbing (8 units tall)
      const tallWallGeometry = new THREE.BoxGeometry(0.5, 8, 6);

      // Blocking wall geometry (smaller walls on platform)
      const smallWallGeometry = new THREE.BoxGeometry(0.5, 2, 2);


      // --- Level Design (Improved) ---

      // 1. Initial Dash/Jump Test (Requires dash to clear easily)
      zPos += platformDepth + 3; // Increase initial gap
      addPlatform(0, yPos, zPos, platformWidth, platformHeight, platformDepth, 0x8b4513);
      zPos += platformDepth + 1; // Standard gap

      // 2. Climbing Wall 1
      yPos += 1.5;
      let plat1 = addPlatform(-5, yPos, zPos, 3, platformHeight, 4, 0x8b4513);
      
      let tallLeftWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallLeftWall.position.set(plat1.position.x - 1.25, plat1.position.y + 4, plat1.position.z);
      scene.add(tallLeftWall);
      walls.push(tallLeftWall);

      let tallRightWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallRightWall.position.set(plat1.position.x - 2.75, plat1.position.y + 4, plat1.position.z);
      scene.add(tallRightWall);
      walls.push(tallRightWall);
      
      // Dash jump target after wall climb
      zPos += platformDepth + 4;
      yPos += 3;
      addPlatform(5, yPos, zPos, platformWidth, platformHeight, platformDepth, 0x8b4513);
      
      // 3. Low Ceiling Dash Section (Must dash to maintain momentum)
      yPos += 1.5;
      zPos += platformDepth + 1;
      let lowPlat = addPlatform(10, yPos, zPos, platformWidth, platformHeight, 2, 0x8b4513);

      // Low ceiling above the platform
      addPlatform(10, yPos + 1.2, zPos, 4, 0.2, 2, 0x777777); // Player height is 1, jump height is 6. Must dash under or jump over/around.

      yPos += 0.5;
      zPos += 4;
      addPlatform(10, yPos, zPos, platformWidth, platformHeight, platformDepth, 0x8b4513);

      // 4. Moving Platform Challenge with Spike
      yPos += 1;
      zPos += platformDepth + 2;
      let movingPlat = addPlatform(5, yPos, zPos, 3, platformHeight, 3, 0x1e90ff);
      movingPlat.userData.moving = {amplitude:6, speed:1.2, axis:'x', base: movingPlat.position.x};

      // Spike on moving platform
      let spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
      spike.castShadow = true;
      spike.receiveShadow = true;
      spike.position.set(movingPlat.position.x, movingPlat.position.y + platformHeight/2 + 0.5, movingPlat.position.z);
      scene.add(spike);
      spikes.push({mesh: spike, platform: movingPlat});

      // 5. Final Climb Wall & Win Platform
      yPos += 2.5;
      zPos += 6;
      let finalPlat = addPlatform(0, yPos, zPos, platformWidth, platformHeight, 4, 0x8b4513);

      let finalWallLeft = new THREE.Mesh(tallWallGeometry, wallMaterial);
      finalWallLeft.position.set(finalPlat.position.x - 1.25, finalPlat.position.y + 4, finalPlat.position.z);
      scene.add(finalWallLeft);
      walls.push(finalWallLeft);

      let finalWallRight = new THREE.Mesh(tallWallGeometry, wallMaterial);
      finalWallRight.position.set(finalPlat.position.x + 1.25, finalPlat.position.y + 4, finalPlat.position.z);
      scene.add(finalWallRight);
      walls.push(finalWallRight);
      
      // Final glowing win platform far away and higher (Dash needed from the top of the wall)
      yPos += 5;
      zPos += 6;
      const winP = addPlatform(10, yPos, zPos, 6, 0.5, 6, 0xffff00);
      winP.userData.win = true;


      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if(e.code === 'Space' || e.code === 'Numpad0'){
          jumpInputBufferTimer = JUMP_INPUT_BUFFER_TIME;
        }
        if(e.code === 'ShiftLeft' && dashCooldownTimer <= 0 && !isDashing){
            // Trigger dash
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;
            
            // Calculate movement direction relative to camera
            let angle = orbitAngleY;
            let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
            let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
            
            dashDirection.set(0,0,0);
            if(dirX !== 0 || dirZ !== 0) {
                dashDirection.addScaledVector(forward, dirZ);
                dashDirection.addScaledVector(right, dirX);
                dashDirection.normalize();
            } else {
                // If no input, dash in the camera's forward direction
                dashDirection.copy(forward);
            }

            // Start Dash
            isDashing = true;
            dashTimer = DASH_DURATION;
            player.material.color.setHex(dashPlayerColor);
            playSound('dash');
            
            // Optionally, reset vertical velocity to maintain a horizontal dash
            velocity.y = Math.min(velocity.y, 0.5); 
        }
      });
      window.addEventListener('keyup', e => keys[e.code] = false);

      renderer.domElement.addEventListener('mousedown', onMouseDown);
      window.addEventListener('mouseup', onMouseUp);
      window.addEventListener('mousemove', onMouseMove);
    }

    function addPlatform(x,y,z,w,h,d,color) {
      const g = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.MeshStandardMaterial({color: color});
      const mesh = new THREE.Mesh(g,m);
      mesh.receiveShadow = true;
      mesh.position.set(x,y,z);
      mesh.userData.size = {x:w,y:h,z:d};
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) <= (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) <= (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) <= (aSize.z + bSize.z);
    }

    function handleJump(isWallJump, wallDir) {
        if(isWallJump) {
            velocity.y = 7.5;
            velocity.x = -8 * wallDir;
            playSound('walljump');
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
        } else {
            velocity.y = 6;
            playSound('jump');
        }
        onGround = false;
        jumpInputBufferTimer = 0;
    }

    function physics(delta) {
      if(gameOver || win) return;

      // Update timers
      if (!canWallJump && !onGround) {
        wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
      }
      jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
      dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);

      // Handle Dash Logic
      if(isDashing) {
          dashTimer -= delta;
          if(dashTimer <= 0) {
              isDashing = false;
              dashCooldownTimer = DASH_COOLDOWN;
              player.material.color.setHex(defaultPlayerColor);
              // After dash, reduce horizontal velocity for control
              velocity.x *= 0.5; 
              velocity.z *= 0.5;
          } else {
              // Apply dash velocity
              player.position.addScaledVector(dashDirection, DASH_SPEED * delta);
              // Skip other physics/gravity during dash
              onGround = false;
              return; 
          }
      }

      let isTouchingWall = false;
      let currentWallDir = 0;

      // 1. Horizontal Movement 
      let dirX = 0, dirZ = 0;
      if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
      if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
      if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
      if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

      const speed = 6;
      if(dirX !== 0 || dirZ !== 0) {
        let angle = orbitAngleY;
        let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
        let moveDir = new THREE.Vector3();
        moveDir.addScaledVector(forward, dirZ);
        moveDir.addScaledVector(right, dirX);
        moveDir.normalize();
        player.position.addScaledVector(moveDir, speed * delta);
      }
      
      // 2. Wall detection for wall jump
      const pPos = player.position.clone();
      const half = {x:0.5,y:0.5,z:0.5};

      for(let w of walls){
        const wPos = w.position;
        const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
        if(aabbIntersect(pPos, half, wPos, wSize)){
          let diffX = pPos.x - wPos.x;
          if(Math.abs(diffX) > 0.01){
            isTouchingWall = true;
            currentWallDir = diffX > 0 ? 1 : -1;
            break;
          }
        }
      }

      if (isTouchingWall && !onGround) {
        canWallJump = true;
        wallJumpDirection = currentWallDir;
        wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
        
        // Wall Slide
        if (velocity.y < 0) {
            velocity.y = Math.max(velocity.y, -1.5);
        }
      } else if (!isTouchingWall && canWallJump) {
          canWallJump = false;
      } else if (onGround) {
          canWallJump = false;
          wallJumpCoyoteTimer = 0;
      }
      
      // 3. Jump Execution
      const isJumpPressed = (keys['Space'] || keys['Numpad0']);
      const canJump = onGround && isJumpPressed;
      const canWallJumpNow = isTouchingWall && jumpInputBufferTimer > 0;
      const canCoyoteJump = wallJumpCoyoteTimer > 0 && isJumpPressed && !onGround && !isTouchingWall;

      if(canJump){
        handleJump(false, 0);
      } else if(canWallJumpNow){
        handleJump(true, currentWallDir);
      } else if(canCoyoteJump){
        handleJump(true, wallJumpDirection); 
      }

      // Apply Gravity
      velocity.y -= 9.8 * delta;

      // Apply velocity X separately for wall jump
      player.position.x += velocity.x * delta;
      velocity.x *= 0.8; 
      player.position.z += velocity.z * delta; // New: Apply Z velocity too for dash effect
      velocity.z *= 0.8; // Friction for Z velocity

      player.position.y += velocity.y * delta;

      onGround = false;

      // 4. Platform Collision
      for(let pl of platforms) {
        if(pl.userData.moving){
          const t = performance.now()/1000;
          const m = pl.userData.moving;
          if(m.axis === 'x') pl.position.x = m.base + Math.sin(t*m.speed) * m.amplitude;
          else pl.position.z = m.base + Math.sin(t*m.speed) * m.amplitude;
        }
        const size = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
        if(aabbIntersect(pPos, half, pl.position, size)) {
          const playerBottom = player.position.y - 0.5;
          const plTop = pl.position.y + size.y;
          const penetration = plTop - playerBottom;
          if(velocity.y <= 0 && penetration > 0 && Math.abs(player.position.x - pl.position.x) < (size.x+half.x) && Math.abs(player.position.z - pl.position.z) < (size.z+half.z)){
            player.position.y += penetration + 0.001;
            velocity.y = 0;
            onGround = true;
            // Reset horizontal velocity on ground, including Z
            velocity.x = 0;
            velocity.z = 0;

            if(pl.userData.moving){
              player.position.x += (pl.position.x - (pl.userData._lastX ?? pl.position.x));
              player.position.z += (pl.position.z - (pl.userData._lastZ ?? pl.position.z));
            }

            if(pl.userData.win && !win){
              win = true;
              playSound('win');
              showWin();
            }
            
            // Reset wall jump states upon landing
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
            // Reset dash cooldown upon landing (refill dash)
            dashCooldownTimer = 0; 
          }
          pl.userData._lastX = pl.position.x;
          pl.userData._lastZ = pl.position.z;
        }
      }

      // 5. Collide with walls to prevent going through
      for(let w of walls){
        const wPos = w.position;
        const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
        if(aabbIntersect(player.position, half, wPos, wSize)){
          // Push player out horizontally from wall
          let diffX = player.position.x - wPos.x;
          let diffZ = player.position.z - wPos.z;
          
          // Determine dominant axis of collision
          if(Math.abs(diffX) > Math.abs(diffZ)) {
              // Collision on X axis
              if(diffX > 0){
                player.position.x = wPos.x + wSize.x + 0.5 + 0.01;
                velocity.x = Math.max(velocity.x, 0);
              } else {
                player.position.x = wPos.x - wSize.x - 0.5 - 0.01;
                velocity.x = Math.min(velocity.x, 0);
              }
          } else {
              // Collision on Z axis
              if(diffZ > 0){
                player.position.z = wPos.z + wSize.z + 0.5 + 0.01;
                velocity.z = Math.max(velocity.z, 0);
              } else {
                player.position.z = wPos.z - wSize.z - 0.5 - 0.01;
                velocity.z = Math.min(velocity.z, 0);
              }
          }
        }
      }

      // 6. Check spikes collision (game over)
      for(let s of spikes){
        const sp = s.mesh.position;
        if(player.position.distanceTo(sp) < 0.7){
          triggerGameOver();
          break;
        }
      }

      // Keep player above the floor plane
      if(player.position.y < -5){
        triggerGameOver();
      }
    }

    function triggerGameOver() {
      if(gameOver) return;
      gameOver = true;
      playSound('gameover');
      document.getElementById('gameOverPanel').style.display = '';
      document.getElementById('overlay').style.display = '';
    }

    function updateCamera() {
      // Smoothly update the camera target (where the camera looks)
      cameraTarget.x = THREE.MathUtils.lerp(cameraTarget.x, player.position.x, CAMERA_SMOOTHING);
      cameraTarget.y = THREE.MathUtils.lerp(cameraTarget.y, player.position.y + 0.5, CAMERA_SMOOTHING);
      cameraTarget.z = THREE.MathUtils.lerp(cameraTarget.z, player.position.z, CAMERA_SMOOTHING);
      
      orbitAngleX = Math.min(Math.max(0.1, orbitAngleX), Math.PI/2 - 0.1);
      const x = cameraTarget.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
      const y = cameraTarget.y + orbitRadius * Math.sin(orbitAngleX);
      const z = cameraTarget.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
      camera.position.set(x, y, z);
      camera.lookAt(cameraTarget);
    }

    function animate() {
      const delta = Math.min(0.05, clock.getDelta());
      physics(delta);
      updateCamera();
      renderer.render(scene, camera);
      if(!gameOver && !win) requestAnimationFrame(animate);
    }

    function respawn() {
      player.position.set(0, 2, 0);
      velocity.set(0,0,0);
      win = false;
      gameOver = false;
      canWallJump = false;
      wallJumpDirection = 0;
      wallJumpCoyoteTimer = 0;
      jumpInputBufferTimer = 0;
      isDashing = false;
      dashCooldownTimer = 0;
      player.material.color.setHex(defaultPlayerColor);
      document.getElementById('winPanel').style.display = 'none';
      document.getElementById('gameOverPanel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';
      clock.start();
      animate();
    }

    function showWin() {
      document.getElementById('startPanel').style.display = 'none';
      const winPanel = document.getElementById('winPanel');
      winPanel.style.display = '';
      document.getElementById('overlay').style.display = '';
    }

    function onMouseDown(e) {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    }

    function onMouseUp() {
      isDragging = false;
    }

    function onMouseMove(e) {
      if(!isDragging) return;
      let deltaX = e.clientX - dragStart.x;
      let deltaY = e.clientY - dragStart.y;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      orbitAngleY -= deltaX * dragSensitivity;
      orbitAngleX -= deltaY * dragSensitivity;
    }

    window.addEventListener('DOMContentLoaded', () => {
      audioCtx = new AudioContext();
      init();
      // Initialize camera target to player's starting position
      cameraTarget.copy(player.position);
      cameraTarget.y += 0.5;

      document.getElementById('startBtn').addEventListener('click', () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        document.getElementById('overlay').style.display = 'none';
        clock.start();
        animate();
      });
      document.getElementById('restartBtn').addEventListener('click', () => location.reload());
      document.getElementById('gameOverRestartBtn').addEventListener('click', () => {
        document.getElementById('gameOverPanel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        respawn();
      });
      window.addEventListener('keydown', e => {
        if(e.code === 'KeyR') respawn();
      });
    });
  </script>
</body>
</html>

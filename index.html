<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Platformer - World Map Edition</title>
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
  
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
    
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      color: white;
      z-index: 2;
      user-select: none;
      font-size: 14px;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }
    
    /* Mini-Map Styles */
    #minimap-container {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 150px;
        height: 150px;
        border: 2px solid white;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2;
        border-radius: 50%; /* Circle map */
        overflow: hidden;
    }
    #minimap {
        width: 100%;
        height: 100%;
        display: block;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
      background: rgba(0,0,0,0.6); 
      backdrop-filter: blur(4px);
    }
    .panel {
      background: rgba(20, 20, 20, 0.9);
      padding: 30px;
      border-radius: 12px;
      color: white;
      min-width: 300px;
      max-width: 400px;
      text-align: center;
      border: 1px solid #444;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    /* Level Select Grid */
    .level-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 20px 0;
    }
    .level-btn {
        padding: 15px;
        background: #333;
        border: 2px solid #555;
        color: #888;
        cursor: not-allowed;
        border-radius: 8px;
        font-weight: bold;
    }
    .level-btn.unlocked {
        background: #228b22; /* Green */
        color: white;
        border-color: #2e8b57;
        cursor: pointer;
    }
    .level-btn.unlocked:hover {
        background: #32cd32;
    }
    .level-btn.locked {
        opacity: 0.5;
    }

    .settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 15px;
        text-align: left;
    }
    button {
      padding: 10px 20px;
      border-radius: 6px;
      border: none;
      background: #007acc;
      color: white;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 5px;
      transition: background 0.2s;
    }
    button:hover { background: #005f9e; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="stageInfo" style="font-size: 18px; font-weight: bold;">Stage: 1-1</div>
    <div style="margin-top: 5px; opacity: 0.8;">WASD: Move | Space: Jump | Shift: Dash</div>
    <div style="margin-top: 5px; opacity: 0.8;">Mouse: Rotate Camera | Esc: Menu</div>
  </div>

  <div id="minimap-container">
      <canvas id="minimap" width="150" height="150"></canvas>
  </div>

  <div id="overlay">
    
    <div class="panel" id="levelSelectPanel">
      <h2 style="margin:0 0 15px 0">World Map Select</h2>
      <div>Choose a stage to begin:</div>
      
      <div class="level-grid" id="levelGrid">
          </div>
      
      <button id="showSettingsBtn">Settings (G)</button>
      <button id="showControlsBtn">Controls (C)</button>
    </div>
    
    <div class="panel" id="controlsPanel" style="display:none;">
      <h2 style="margin:0">Controls</h2>
      <div style="text-align: left; margin: 20px 0; line-height: 1.6;">
        <b>Movement:</b> WASD or Arrows<br>
        <b>Jump:</b> Spacebar<br>
        <b>Dash:</b> Shift (Air or Ground)<br>
        <b>Wall Jump:</b> Jump while touching wall<br>
        <b>Look:</b> Mouse Movement<br>
        <b>Pause:</b> Esc<br>
        <b>Respawn:</b> R
      </div>
      <button id="closeControlsBtn">Back</button>
    </div>

    <div class="panel" id="settingsPanel" style="display:none;">
      <h2>Settings</h2>
      <div class="settings-grid">
        <label>Music Volume</label>
        <input type="range" id="volumeRange" min="0" max="100" value="50">
        
        <label>Player Color</label>
        <input type="color" id="playerColorPicker" value="#FF8C00">
        
        <label>Camera Dist</label>
        <input type="range" id="cameraDistanceRange" min="5" max="20" value="12">
      </div>
      <button id="closeSettingsBtn" style="margin-top: 20px;">Back</button>
    </div>
    
    <div class="panel" id="winPanel" style="display:none;">
      <h2 id="winTitle">Stage Complete! üéâ</h2>
      <button id="nextLevelBtn">Next Stage</button>
      <button id="menuBtnWin">World Map</button>
    </div>
    
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="color:#ff4444;">Game Over</h2>
      <div style="margin-bottom: 15px;">You fell or hit a hazard!</div>
      <button id="gameOverRestartBtn">Try Again</button>
      <button id="menuBtnLose">World Map</button>
    </div>
    
    <div class="panel" id="pausePanel" style="display:none;">
      <h2>Paused</h2>
      <button id="resumeBtn">Resume</button>
      <button id="pauseRestartBtn">Restart Level</button>
      <button id="menuBtnPause">World Map</button>
    </div>
  </div>
  
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  
  <script>
    // --- Global Variables ---
    let scene, camera, renderer;
    let player, platforms = [], walls = [], hazards = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;
    let isPaused = true; 
    let animationFrameId = null;

    // --- Level Management ---
    let currentStage = 1;
    const TOTAL_STAGES = 3; 
    let maxStageReached = 1; // Default to 1

    // --- Minimap Context ---
    let minimapCtx;
    const MAP_SCALE = 4; // 1 world unit = 4 pixels

    // --- Settings ---
    let currentSettings = {
        volume: 0.5, 
        playerColor: '#FF8C00',
        cameraDistance: 12,
    };

    // --- Physics Constants ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.1;
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.15;
    let jumpInputBufferTimer = 0;
    const WALL_JUMP_LOCKOUT_TIME = 0.2; 
    let horizontalLockoutTimer = 0; 

    let isDashing = false;
    const DASH_SPEED = 20;
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    const DASH_COOLDOWN = 0.7; 
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3();
    
    const JUMP_POWER = 7.0;
    const WALL_JUMP_POWER = 8.5;

    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let dragSensitivity = 0.005;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.1;
    let orbitRadius = 12;

    // Audio
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let backgroundMusic = null;
    let musicGainNode = null; 

    // --- Persistence & Settings ---

    function loadSettings() {
        const savedSettings = localStorage.getItem('platformerSettings');
        const savedProgress = localStorage.getItem('platformerMaxStage');
        
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                currentSettings.volume = parseFloat(settings.volume || 0.5);
                currentSettings.playerColor = settings.playerColor || '#FF8C00';
                currentSettings.cameraDistance = parseFloat(settings.cameraDistance || 12);
            } catch (e) {}
        }
        
        if (savedProgress) {
            maxStageReached = parseInt(savedProgress) || 1;
        }

        // Apply to UI
        if (document.getElementById('volumeRange')) document.getElementById('volumeRange').value = currentSettings.volume * 100;
        if (document.getElementById('playerColorPicker')) document.getElementById('playerColorPicker').value = currentSettings.playerColor;
        if (document.getElementById('cameraDistanceRange')) document.getElementById('cameraDistanceRange').value = currentSettings.cameraDistance;
        
        orbitRadius = currentSettings.cameraDistance;
        updateLevelGrid();
    }

    function saveSettings() {
        localStorage.setItem('platformerSettings', JSON.stringify(currentSettings));
    }
    
    function saveProgress() {
        if (currentStage >= maxStageReached && currentStage < TOTAL_STAGES) {
            maxStageReached = currentStage + 1;
            localStorage.setItem('platformerMaxStage', maxStageReached);
        }
        updateLevelGrid();
    }

    function updateLevelGrid() {
        const grid = document.getElementById('levelGrid');
        grid.innerHTML = ''; // Clear existing
        
        for (let i = 1; i <= TOTAL_STAGES; i++) {
            const btn = document.createElement('button');
            btn.className = `level-btn ${i <= maxStageReached ? 'unlocked' : 'locked'}`;
            btn.textContent = `Level ${i}`;
            btn.disabled = i > maxStageReached;
            
            btn.addEventListener('click', () => {
                if (i <= maxStageReached) {
                    loadStage(i);
                }
            });
            grid.appendChild(btn);
        }
    }

    function applySettings() {
        if (musicGainNode) musicGainNode.gain.setTargetAtTime(currentSettings.volume * 0.5, audioCtx.currentTime, 0.05); 
        if (player && !isDashing) player.material.color.set(currentSettings.playerColor);
        orbitRadius = currentSettings.cameraDistance;
    }

    // --- Audio ---
    const notes = [261.63, 329.63, 392.00, 523.25]; // Simple C Major Arpeggio
    function playMusic() {
      if (!audioCtx || backgroundMusic) return;
      if (!musicGainNode) {
        musicGainNode = audioCtx.createGain();
        musicGainNode.gain.setValueAtTime(currentSettings.volume * 0.5, audioCtx.currentTime); 
        musicGainNode.connect(audioCtx.destination);
      }
      
      let noteIndex = 0;
      function next() {
          if (isPaused || gameOver || win) { backgroundMusic = null; return; }
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(notes[noteIndex % notes.length], audioCtx.currentTime);
          osc.connect(musicGainNode);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.2);
          noteIndex++;
          backgroundMusic = setTimeout(next, 300);
      }
      next();
    }

    function stopMusic() {
        if(backgroundMusic) { clearTimeout(backgroundMusic); backgroundMusic = null; }
    }

    function playSound(type) {
      if(!audioCtx || isPaused) return;
      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      let vol = currentSettings.volume * 0.5;
      
      if(type === 'jump') {
          osc.frequency.setValueAtTime(400, now);
          osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
          gain.gain.setValueAtTime(vol, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          osc.start(now); osc.stop(now + 0.1);
      } else if (type === 'dash') {
          osc.type = 'square';
          osc.frequency.setValueAtTime(200, now);
          gain.gain.setValueAtTime(vol, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
          osc.start(now); osc.stop(now + 0.15);
      }
    }

    // --- Game Engine ---

    // ** DEFINED BEFORE INIT TO FIX REFERENCE ERROR **
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function init() {
      // Setup Three.js
      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas-holder').appendChild(renderer.domElement);

      // Setup Minimap Canvas
      const minimapCanvas = document.getElementById('minimap');
      minimapCtx = minimapCanvas.getContext('2d');

      // Base Lighting (will be augmented by stage settings)
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(20, 50, 20);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      scene.add(dir);

      // Player
      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color: currentSettings.playerColor});
      player = new THREE.Mesh(geom, mat);
      player.castShadow = true;
      scene.add(player);

      // Event Listeners
      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', handleKeyDown); 
      window.addEventListener('keyup', e => keys[e.code] = false);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      
      // Load Minimap Logic
      minimapCanvas.width = 150;
      minimapCanvas.height = 150;
    }

    function clearLevel() {
        // Remove old level objects
        [...platforms, ...walls, ...hazards].forEach(obj => {
            if(obj.mesh) scene.remove(obj.mesh);
            else scene.remove(obj);
        });
        platforms = [];
        walls = [];
        hazards = [];
    }

    function loadStage(stageNum) {
        clearLevel();
        currentStage = stageNum;
        document.getElementById('stageInfo').textContent = `Stage: ${currentStage}`;
        
        // Reset Player
        player.position.set(0, 2, 0);
        velocity.set(0,0,0);
        player.rotation.set(0,0,0);
        
        // --- SCENARIO SETTINGS ---
        let groundColor, wallColor, skyColor;
        
        if (stageNum === 1) { // Day
            skyColor = 0x87ceeb; // Light Blue
            groundColor = 0x556b2f; // Green
            wallColor = 0x8b4513; // Wood
        } else if (stageNum === 2) { // Sunset
            skyColor = 0xffa07a; // Salmon/Orange
            groundColor = 0x8b4513; // Brown dirt
            wallColor = 0xcd5c5c; // Reddish
        } else { // Night
            skyColor = 0x0a0a2a; // Dark Blue
            groundColor = 0x555555; // Grey Stone
            wallColor = 0x333333; // Dark Stone
        }
        
        scene.background = new THREE.Color(skyColor);
        const wallMat = new THREE.MeshStandardMaterial({color: wallColor});

        // --- LEVEL GEOMETRY ---
        
        // Base Floor
        addBlock(0, -1, 0, 30, 1, 30, groundColor);

        if (stageNum === 1) {
            // Stage 1: Basic Jumps & Wall Climb
            addBlock(0, 0, 8, 5, 0.5, 5, wallColor);
            addBlock(0, 1, 16, 5, 0.5, 5, wallColor);
            
            // Wall Climb Tower
            const tX = 0, tZ = 25;
            addBlock(tX, 2, tZ, 5, 0.5, 5, wallColor); // Entry
            // Walls
            addWall(tX - 2.5, 8, tZ, 0.5, 12, 5, wallMat); // Left
            addWall(tX + 2.5, 8, tZ, 0.5, 12, 5, wallMat); // Right
            addWall(tX, 8, tZ + 2.5, 5.5, 12, 0.5, wallMat); // Back
            
            addBlock(tX, 14.5, tZ, 5, 0.5, 5, groundColor); // Top
            
            // Win
            const winP = addBlock(tX, 16, tZ - 8, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
        } else if (stageNum === 2) {
            // Stage 2: Rotating Hazard Fix
            addBlock(0, 0, 10, 4, 0.5, 4, wallColor);
            
            // Rotating Red Bar (Hazard)
            const rotBar = addBlock(0, 1.5, 10, 8, 0.5, 0.5, 0xff0000);
            rotBar.userData.rotating = { speed: 1.5 };
            // IMPORTANT: Mark as hazard but treat as CYLINDER collision in physics
            hazards.push({ mesh: rotBar, type: 'rotator', radius: 4 }); 
            
            addBlock(0, 0, 20, 4, 0.5, 4, wallColor);
            
            // Moving Platform
            let mp = addBlock(10, 2, 20, 4, 0.5, 4, 0x0000ff);
            mp.userData.moving = { axis: 'x', base: 10, amplitude: 5, speed: 1 };
            
            const winP = addBlock(10, 4, 30, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
        } else if (stageNum === 3) {
            // Stage 3: Night Climb
            addBlock(0, 0, 10, 5, 0.5, 5, 0x444444);
            
            // Parkour pillars
            addBlock(-6, 2, 15, 2, 0.5, 2, 0x444444);
            addBlock(6, 4, 15, 2, 0.5, 2, 0x444444);
            addBlock(0, 6, 20, 2, 0.5, 2, 0x444444);
            
            // Huge Wall
            addWall(0, 15, 30, 15, 20, 1, wallMat);
            
            const winP = addBlock(0, 26, 28, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
        }

        // Start Game Loop
        resumeGame();
    }

    function addBlock(x, y, z, w, h, d, color) {
        const g = new THREE.BoxGeometry(w, h, d);
        const m = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(g, m);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.size = { x: w, y: h, z: d };
        scene.add(mesh);
        platforms.push(mesh);
        return mesh;
    }

    function addWall(x, y, z, w, h, d, material) {
        const g = new THREE.BoxGeometry(w, h, d);
        const mesh = new THREE.Mesh(g, material);
        mesh.position.set(x, y, z);
        mesh.receiveShadow = true;
        mesh.userData.size = { x: w, y: h, z: d };
        scene.add(mesh);
        walls.push(mesh);
        return mesh;
    }

    // --- Physics ---

    function physics(delta) {
        if(isPaused || gameOver || win) return;

        // Timers
        if (!canWallJump && !onGround) wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
        jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
        dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);
        horizontalLockoutTimer = Math.max(0, horizontalLockoutTimer - delta);

        // Dash
        if(isDashing) {
            dashTimer -= delta;
            if(dashTimer <= 0) {
                isDashing = false;
                dashCooldownTimer = DASH_COOLDOWN;
                player.material.color.set(currentSettings.playerColor);
                velocity.x *= 0.1; velocity.z *= 0.1;
            } else {
                velocity.x = dashDirection.x * DASH_SPEED;
                velocity.z = dashDirection.z * DASH_SPEED;
                velocity.y = 0;
            }
        }

        // Horizontal Move
        if (!isDashing && horizontalLockoutTimer === 0) {
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

            const speed = 6;
            if(dirX !== 0 || dirZ !== 0) {
                let angle = orbitAngleY;
                let sin = Math.sin(angle), cos = Math.cos(angle);
                // Rotate input vector by camera angle
                let moveX = dirZ * sin + dirX * cos;
                let moveZ = dirZ * cos - dirX * sin;
                
                // Normalize roughly
                const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                if(len > 0) { moveX/=len; moveZ/=len; }

                player.position.x += moveX * speed * delta;
                player.position.z += moveZ * speed * delta;
            }
        }

        const pPos = player.position.clone();
        const half = {x:0.5, y:0.5, z:0.5};

        // Wall Collision
        let isTouchingWall = false;
        let currentWallDir = 0;

        for(let w of walls) {
            const wPos = w.position;
            const wSize = {x:w.userData.size.x/2, y:w.userData.size.y/2, z:w.userData.size.z/2};
            
            // AABB Check
            if (Math.abs(pPos.x - wPos.x) < half.x + wSize.x &&
                Math.abs(pPos.y - wPos.y) < half.y + wSize.y &&
                Math.abs(pPos.z - wPos.z) < half.z + wSize.z) {
                
                // Penetration resolution
                let penX = (half.x + wSize.x) - Math.abs(pPos.x - wPos.x);
                let penZ = (half.z + wSize.z) - Math.abs(pPos.z - wPos.z);

                if (penX < penZ) {
                    // X Collision
                    if (pPos.x > wPos.x) { player.position.x += penX; isTouchingWall = true; currentWallDir = 1; }
                    else { player.position.x -= penX; isTouchingWall = true; currentWallDir = -1; }
                    velocity.x = 0;
                } else {
                    // Z Collision
                    if (pPos.z > wPos.z) { player.position.z += penZ; isTouchingWall = true; currentWallDir = 1; } 
                    else { player.position.z -= penZ; isTouchingWall = true; currentWallDir = -1; }
                    velocity.z = 0;
                }
            }
        }

        // Wall Jump State
        if (isTouchingWall && !onGround) {
            canWallJump = true;
            wallJumpDirection = currentWallDir;
            wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
            if (velocity.y < 0) velocity.y = Math.max(velocity.y, -1.5); // Slide
        } else if (!isTouchingWall && canWallJump) {
            canWallJump = false;
        } else if (onGround) {
            canWallJump = false;
        }

        // Jump
        if ((keys['Space'] || keys['Numpad0']) && (onGround || (canWallJump && jumpInputBufferTimer > 0))) {
            velocity.y = canWallJump && !onGround ? WALL_JUMP_POWER : JUMP_POWER;
            
            if (canWallJump && !onGround) {
                // Wall jump push
                velocity.x = -8 * (player.position.x - pPos.x > 0 ? 1 : -1); 
                if (Math.abs(velocity.x) < 1) velocity.z = -8 * (player.position.z - pPos.z > 0 ? 1 : -1);
                
                horizontalLockoutTimer = WALL_JUMP_LOCKOUT_TIME;
                playSound('jump'); // reuse sound
            } else {
                playSound('jump');
            }
            onGround = false;
            jumpInputBufferTimer = 0;
            keys['Space'] = false; // Prevent holding
        }

        // Gravity
        velocity.y -= 25 * delta; // Stronger gravity
        player.position.y += velocity.y * delta;

        // Apply Velocity X/Z
        if (horizontalLockoutTimer === 0) {
            velocity.x *= 0.9;
            velocity.z *= 0.9;
        }
        player.position.x += velocity.x * delta;
        player.position.z += velocity.z * delta;

        onGround = false;

        // Platform Collision
        for(let pl of platforms) {
            // Update Moving Platform
            if(pl.userData.moving) {
                const t = clock.getElapsedTime();
                const m = pl.userData.moving;
                if(m.axis === 'x') pl.position.x = m.base + Math.sin(t * m.speed) * m.amplitude;
                if(m.axis === 'z') pl.position.z = m.base + Math.sin(t * m.speed) * m.amplitude;
            }

            // AABB
            const wSize = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
            if (Math.abs(player.position.x - pl.position.x) < half.x + wSize.x &&
                Math.abs(player.position.y - pl.position.y) < half.y + wSize.y &&
                Math.abs(player.position.z - pl.position.z) < half.z + wSize.z) {
                
                // Only land on top
                if (velocity.y <= 0 && player.position.y > pl.position.y + wSize.y - 0.2) {
                    player.position.y = pl.position.y + wSize.y + half.y;
                    velocity.y = 0;
                    onGround = true;
                    
                    // Win Check
                    if (pl.userData.win && !win) {
                        winStage();
                    }
                }
            }
        }

        // Hazard Collision (Rotating Red Bar Fix)
        for(let h of hazards) {
            if (h.type === 'rotator') {
                h.mesh.rotation.y += delta * 2;
                // Cylinder/Radius Check - Rotation Independent!
                const dist = Math.sqrt(
                    Math.pow(player.position.x - h.mesh.position.x, 2) + 
                    Math.pow(player.position.z - h.mesh.position.z, 2)
                );
                // Check height overlap
                if (Math.abs(player.position.y - h.mesh.position.y) < 0.5 && dist < h.radius) {
                    die();
                }
            }
        }

        if (player.position.y < -10) die();
    }

    function die() {
        if(gameOver || win) return;
        gameOver = true;
        playSound('dash'); // reuse fail sound
        showPanel('gameOverPanel');
        isPaused = true;
    }

    function winStage() {
        win = true;
        saveProgress();
        showPanel('winPanel');
        isPaused = true;
    }

    // --- Minimap ---
    function drawMinimap() {
        if (!minimapCtx) return;
        
        // Clear
        minimapCtx.fillStyle = '#222';
        minimapCtx.fillRect(0, 0, 150, 150);
        
        const centerX = 75;
        const centerY = 75;
        
        // Draw Platforms relative to player
        minimapCtx.fillStyle = '#888';
        for(let p of platforms) {
            const relX = (p.position.x - player.position.x) * MAP_SCALE;
            const relZ = (p.position.z - player.position.z) * MAP_SCALE;
            
            // Simple Rect
            const w = p.userData.size.x * MAP_SCALE;
            const h = p.userData.size.z * MAP_SCALE;
            
            // Win platform is Gold
            if (p.userData.win) minimapCtx.fillStyle = 'gold';
            else minimapCtx.fillStyle = '#666';

            minimapCtx.fillRect(centerX + relX - w/2, centerY + relZ - h/2, w, h);
        }
        
        // Draw Player
        minimapCtx.fillStyle = currentSettings.playerColor;
        minimapCtx.beginPath();
        minimapCtx.arc(centerX, centerY, 3, 0, Math.PI*2);
        minimapCtx.fill();
        
        // Draw Camera Cone (Direction)
        const camDirX = Math.sin(orbitAngleY);
        const camDirZ = Math.cos(orbitAngleY);
        
        minimapCtx.strokeStyle = 'white';
        minimapCtx.beginPath();
        minimapCtx.moveTo(centerX, centerY);
        minimapCtx.lineTo(centerX + camDirX * 10, centerY + camDirZ * 10);
        minimapCtx.stroke();
    }

    // --- UI Helpers ---
    function showPanel(id) {
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById(id).style.display = 'block';
        document.exitPointerLock();
    }

    function hidePanels() {
        document.getElementById('overlay').style.display = 'none';
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        document.body.requestPointerLock();
    }

    function resumeGame() {
        isPaused = false;
        hidePanels();
        if (!animationFrameId) animate();
    }

    // --- Input & Loop ---
    function handleKeyDown(e) {
        keys[e.code] = true;
        
        if (e.code === 'Escape') {
            if (document.getElementById('levelSelectPanel').style.display === 'block') return; // Stuck in menu
            if (isPaused) resumeGame();
            else { isPaused = true; showPanel('pausePanel'); }
        }
        
        if (e.code === 'KeyR') {
            loadStage(currentStage); // Quick Restart
        }
    }

    function onMouseMove(e) {
        if (isPaused) return;
        orbitAngleY -= e.movementX * dragSensitivity;
        orbitAngleX -= e.movementY * dragSensitivity;
        orbitAngleX = Math.max(0.1, Math.min(Math.PI/2 - 0.1, orbitAngleX));
    }

    function animate() {
        const delta = Math.min(0.05, clock.getDelta());
        
        if (!isPaused) {
            physics(delta);
            
            // Camera
            const x = player.position.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
            const y = player.position.y + orbitRadius * Math.sin(orbitAngleX);
            const z = player.position.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
            camera.position.set(x, y, z);
            camera.lookAt(player.position);
            
            renderer.render(scene, camera);
            drawMinimap();
        }
        
        animationFrameId = requestAnimationFrame(animate);
    }

    // --- Boot ---
    window.addEventListener('DOMContentLoaded', () => {
        audioCtx = new AudioContext();
        loadSettings();
        init();
        showPanel('levelSelectPanel'); // Start at World Map

        // Button Bindings
        document.getElementById('showSettingsBtn').onclick = () => showPanel('settingsPanel');
        document.getElementById('closeSettingsBtn').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('showControlsBtn').onclick = () => showPanel('controlsPanel');
        document.getElementById('closeControlsBtn').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('resumeBtn').onclick = resumeGame;
        document.getElementById('pauseRestartBtn').onclick = () => loadStage(currentStage);
        document.getElementById('menuBtnPause').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('gameOverRestartBtn').onclick = () => loadStage(currentStage);
        document.getElementById('menuBtnLose').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('nextLevelBtn').onclick = () => {
            if (currentStage < TOTAL_STAGES) loadStage(currentStage + 1);
            else {
                // If beating last stage, go back to 1 (or map)
                currentStage = 1;
                loadStage(1);
            }
        };
        document.getElementById('menuBtnWin').onclick = () => showPanel('levelSelectPanel');

        // Settings inputs
        document.getElementById('volumeRange').oninput = (e) => { currentSettings.volume = e.target.value/100; applySettings(); saveSettings(); };
        document.getElementById('playerColorPicker').oninput = (e) => { currentSettings.playerColor = e.target.value; applySettings(); saveSettings(); };
        document.getElementById('cameraDistanceRange').oninput = (e) => { currentSettings.cameraDistance = parseFloat(e.target.value); applySettings(); saveSettings(); };
    });

  </script>
</body>
</html>

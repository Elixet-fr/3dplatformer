<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Platformer - World Map Edition</title>
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
  
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
    
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      color: white;
      z-index: 2;
      user-select: none;
      font-size: 14px;
      text-shadow: 1px 1px 2px black;
      pointer-events: none;
    }
    
    #minimap-container {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 150px;
        height: 150px;
        border: 2px solid white;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2;
        border-radius: 50%;
        overflow: hidden;
    }
    #minimap {
        width: 100%;
        height: 100%;
        display: block;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
      background: rgba(0,0,0,0.6); 
      backdrop-filter: blur(4px);
    }
    .panel {
      background: rgba(20, 20, 20, 0.9);
      padding: 30px;
      border-radius: 12px;
      color: white;
      min-width: 300px;
      max-width: 400px;
      text-align: center;
      border: 1px solid #444;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    
    .level-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin: 20px 0;
    }
    .level-btn {
        padding: 15px;
        background: #333;
        border: 2px solid #555;
        color: #888;
        cursor: not-allowed;
        border-radius: 8px;
        font-weight: bold;
    }
    .level-btn.unlocked {
        background: #228b22;
        color: white;
        border-color: #2e8b57;
        cursor: pointer;
    }
    .level-btn.unlocked:hover {
        background: #32cd32;
    }
    .settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 15px;
        text-align: left;
    }
    button {
      padding: 10px 20px;
      border-radius: 6px;
      border: none;
      background: #007acc;
      color: white;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 5px;
      transition: background 0.2s;
    }
    button:hover { background: #005f9e; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="stageInfo" style="font-size: 18px; font-weight: bold;">Stage: 1</div>
    <div style="margin-top: 5px; opacity: 0.8;">WASD: Move | Space: Jump | Shift: Dash</div>
    <div style="margin-top: 5px; opacity: 0.8;">Mouse: Look | Esc: Menu | R: Respawn</div>
  </div>

  <div id="minimap-container">
      <canvas id="minimap" width="150" height="150"></canvas>
  </div>

  <div id="overlay">
    
    <div class="panel" id="levelSelectPanel">
      <h2 style="margin:0 0 15px 0">World Map Select</h2>
      <div>Choose a stage:</div>
      <div class="level-grid" id="levelGrid"></div>
      <button id="showSettingsBtn">Settings</button>
      <button id="showControlsBtn">Controls</button>
    </div>
    
    <div class="panel" id="controlsPanel" style="display:none;">
      <h2 style="margin:0">Controls</h2>
      <div style="text-align: left; margin: 20px 0; line-height: 1.6;">
        <b>Move:</b> WASD<br>
        <b>Jump:</b> Space (High Jump!)<br>
        <b>Dash:</b> Shift<br>
        <b>Respawn:</b> R<br>
        <b>Pause:</b> Esc
      </div>
      <button id="closeControlsBtn">Back</button>
    </div>

    <div class="panel" id="settingsPanel" style="display:none;">
      <h2>Settings</h2>
      <div class="settings-grid">
        <label>Music Volume</label>
        <input type="range" id="volumeRange" min="0" max="100" value="50">
        <label>Player Color</label>
        <input type="color" id="playerColorPicker" value="#FF8C00">
        <label>Camera Dist</label>
        <input type="range" id="cameraDistanceRange" min="5" max="25" value="14">
      </div>
      <button id="closeSettingsBtn" style="margin-top: 20px;">Back</button>
    </div>
    
    <div class="panel" id="winPanel" style="display:none;">
      <h2 id="winTitle">Stage Complete! üéâ</h2>
      <button id="nextLevelBtn">Next Stage</button>
      <button id="menuBtnWin">World Map</button>
    </div>
    
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="color:#ff4444;">Game Over</h2>
      <div style="margin-bottom: 15px;">You fell!</div>
      <button id="gameOverRestartBtn">Try Again</button>
      <button id="menuBtnLose">World Map</button>
    </div>
    
    <div class="panel" id="pausePanel" style="display:none;">
      <h2>Paused</h2>
      <button id="resumeBtn">Resume</button>
      <button id="pauseRestartBtn">Restart Level</button>
      <button id="menuBtnPause">World Map</button>
    </div>
  </div>
  
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  
  <script>
    // --- Global Variables ---
    let scene, camera, renderer;
    let player, platforms = [], walls = [], hazards = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;
    let isPaused = true; 
    let animationFrameId = null;

    // --- Config ---
    let currentStage = 1;
    const TOTAL_STAGES = 3; 
    let maxStageReached = 1; 
    let minimapCtx;
    const MAP_SCALE = 4;

    let currentSettings = {
        volume: 0.5, 
        playerColor: '#FF8C00',
        cameraDistance: 14,
    };

    // --- Physics Constants (Tweaked for better feel) ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.15; // Increased slightly
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.2;
    let jumpInputBufferTimer = 0;
    const WALL_JUMP_LOCKOUT_TIME = 0.2; 
    let horizontalLockoutTimer = 0; 

    let isDashing = false;
    const DASH_SPEED = 25; // Faster dash
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    const DASH_COOLDOWN = 0.6; 
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3();
    
    // ** UPDATED JUMP PHYSICS **
    const JUMP_POWER = 14.0; // Doubled height
    const WALL_JUMP_POWER = 16.0;
    const GRAVITY = 50.0; // Higher gravity for snappy feel

    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let dragSensitivity = 0.003;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.15;
    let orbitRadius = 14;

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let backgroundMusic = null;
    let musicGainNode = null; 

    // --- Settings & Save System ---

    function loadSettings() {
        const savedSettings = localStorage.getItem('platformerSettings');
        const savedProgress = localStorage.getItem('platformerMaxStage');
        
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                currentSettings.volume = parseFloat(settings.volume || 0.5);
                currentSettings.playerColor = settings.playerColor || '#FF8C00';
                currentSettings.cameraDistance = parseFloat(settings.cameraDistance || 14);
            } catch (e) {}
        }
        
        if (savedProgress) maxStageReached = parseInt(savedProgress) || 1;

        if (document.getElementById('volumeRange')) document.getElementById('volumeRange').value = currentSettings.volume * 100;
        if (document.getElementById('playerColorPicker')) document.getElementById('playerColorPicker').value = currentSettings.playerColor;
        if (document.getElementById('cameraDistanceRange')) document.getElementById('cameraDistanceRange').value = currentSettings.cameraDistance;
        
        orbitRadius = currentSettings.cameraDistance;
        updateLevelGrid();
    }

    function saveSettings() {
        localStorage.setItem('platformerSettings', JSON.stringify(currentSettings));
    }
    
    function saveProgress() {
        if (currentStage >= maxStageReached && currentStage < TOTAL_STAGES) {
            maxStageReached = currentStage + 1;
            localStorage.setItem('platformerMaxStage', maxStageReached);
        }
        updateLevelGrid();
    }

    function updateLevelGrid() {
        const grid = document.getElementById('levelGrid');
        grid.innerHTML = ''; 
        for (let i = 1; i <= TOTAL_STAGES; i++) {
            const btn = document.createElement('button');
            btn.className = `level-btn ${i <= maxStageReached ? 'unlocked' : 'locked'}`;
            btn.textContent = `Stage ${i}`;
            btn.disabled = i > maxStageReached;
            btn.addEventListener('click', () => { if (i <= maxStageReached) loadStage(i); });
            grid.appendChild(btn);
        }
    }

    function applySettings() {
        if (musicGainNode) musicGainNode.gain.setTargetAtTime(currentSettings.volume * 0.5, audioCtx.currentTime, 0.05); 
        if (player && !isDashing) player.material.color.set(currentSettings.playerColor);
        orbitRadius = currentSettings.cameraDistance;
    }

    // --- Audio ---
    const notes = [261.63, 329.63, 392.00, 523.25];
    function playMusic() {
      if (!audioCtx || backgroundMusic) return;
      if (!musicGainNode) {
        musicGainNode = audioCtx.createGain();
        musicGainNode.gain.setValueAtTime(currentSettings.volume * 0.5, audioCtx.currentTime); 
        musicGainNode.connect(audioCtx.destination);
      }
      let noteIndex = 0;
      function next() {
          if (isPaused || gameOver || win) { backgroundMusic = null; return; }
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(notes[noteIndex % notes.length], audioCtx.currentTime);
          osc.connect(musicGainNode);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.2);
          noteIndex++;
          backgroundMusic = setTimeout(next, 300);
      }
      next();
    }

    function stopMusic() {
        if(backgroundMusic) { clearTimeout(backgroundMusic); backgroundMusic = null; }
    }

    function playSound(type) {
      if(!audioCtx || isPaused) return;
      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      
      let vol = currentSettings.volume * 0.5;
      
      if(type === 'jump') {
          osc.frequency.setValueAtTime(300, now);
          osc.frequency.linearRampToValueAtTime(600, now + 0.1);
          gain.gain.setValueAtTime(vol, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now); osc.stop(now + 0.2);
      } else if (type === 'dash') {
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, now);
          gain.gain.setValueAtTime(vol * 0.5, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now); osc.stop(now + 0.2);
      }
    }

    // --- Core Engine ---

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-holder').appendChild(renderer.domElement);

      const minimapCanvas = document.getElementById('minimap');
      minimapCtx = minimapCanvas.getContext('2d');

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(20, 50, 20);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      scene.add(dir);

      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color: currentSettings.playerColor});
      player = new THREE.Mesh(geom, mat);
      player.castShadow = true;
      scene.add(player);

      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', handleKeyDown); 
      window.addEventListener('keyup', e => keys[e.code] = false);
      
      // FIX: Use document listener for mouse move so camera works when pointer is locked
      document.addEventListener('mousemove', onMouseMove);
      
      minimapCanvas.width = 150;
      minimapCanvas.height = 150;
    }

    function clearLevel() {
        [...platforms, ...walls, ...hazards].forEach(obj => {
            if(obj.mesh) scene.remove(obj.mesh);
            else scene.remove(obj);
        });
        platforms = [];
        walls = [];
        hazards = [];
    }

    function loadStage(stageNum) {
        clearLevel();
        currentStage = stageNum;
        document.getElementById('stageInfo').textContent = `Stage: ${currentStage}`;
        
        // ** FIX: Explicitly Reset Game State **
        win = false;
        gameOver = false;
        isPaused = false;
        velocity.set(0,0,0);
        player.position.set(0, 2, 0);
        player.rotation.set(0,0,0);
        player.scale.set(1,1,1); // Reset animations
        
        // Scenarios
        let groundColor, wallColor, skyColor;
        
        if (stageNum === 1) { 
            skyColor = 0x87ceeb; groundColor = 0x556b2f; wallColor = 0x8b4513;
        } else if (stageNum === 2) { 
            skyColor = 0xffa07a; groundColor = 0x8b4513; wallColor = 0xcd5c5c;
        } else { 
            skyColor = 0x0a0a2a; groundColor = 0x555555; wallColor = 0x333333;
        }
        
        scene.background = new THREE.Color(skyColor);
        const wallMat = new THREE.MeshStandardMaterial({color: wallColor});

        // Floor
        addBlock(0, -1, 0, 40, 1, 40, groundColor);

        if (stageNum === 1) {
            addBlock(0, 0, 8, 5, 0.5, 5, wallColor);
            addBlock(0, 1, 16, 5, 0.5, 5, wallColor);
            
            // Tower
            const tX = 0, tZ = 25;
            addBlock(tX, 2, tZ, 5, 0.5, 5, wallColor); 
            addWall(tX - 2.5, 8, tZ, 0.5, 12, 5, wallMat); 
            addWall(tX + 2.5, 8, tZ, 0.5, 12, 5, wallMat); 
            addWall(tX, 8, tZ + 2.5, 5.5, 12, 0.5, wallMat); 
            addBlock(tX, 14.5, tZ, 5, 0.5, 5, groundColor); 
            
            const winP = addBlock(tX, 16, tZ - 8, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
        } else if (stageNum === 2) {
            addBlock(0, 0, 10, 4, 0.5, 4, wallColor);
            
            // Rotating Hazard
            const rotBar = addBlock(0, 1.5, 10, 8, 0.5, 0.5, 0xff0000);
            rotBar.userData.rotating = { speed: 1.5 };
            // FIX: Using Cylinder Collision type
            hazards.push({ mesh: rotBar, type: 'rotator', radius: 4 }); 
            
            addBlock(0, 0, 20, 4, 0.5, 4, wallColor);
            let mp = addBlock(10, 2, 20, 4, 0.5, 4, 0x0000ff);
            mp.userData.moving = { axis: 'x', base: 10, amplitude: 5, speed: 1 };
            
            const winP = addBlock(10, 4, 30, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
        } else if (stageNum === 3) {
            addBlock(0, 0, 10, 5, 0.5, 5, 0x444444);
            addBlock(-6, 2, 15, 2, 0.5, 2, 0x444444);
            addBlock(6, 4, 15, 2, 0.5, 2, 0x444444);
            addBlock(0, 6, 20, 2, 0.5, 2, 0x444444);
            addWall(0, 15, 30, 15, 20, 1, wallMat);
            const winP = addBlock(0, 26, 28, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
        }

        resumeGame();
    }

    function addBlock(x, y, z, w, h, d, color) {
        const g = new THREE.BoxGeometry(w, h, d);
        const m = new THREE.MeshStandardMaterial({ color: color });
        const mesh = new THREE.Mesh(g, m);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.size = { x: w, y: h, z: d };
        scene.add(mesh);
        platforms.push(mesh);
        return mesh;
    }

    function addWall(x, y, z, w, h, d, material) {
        const g = new THREE.BoxGeometry(w, h, d);
        const mesh = new THREE.Mesh(g, material);
        mesh.position.set(x, y, z);
        mesh.receiveShadow = true;
        mesh.userData.size = { x: w, y: h, z: d };
        scene.add(mesh);
        walls.push(mesh);
        return mesh;
    }

    // --- Physics ---

    function updateAnimations(delta) {
        if (!player || isDashing) return;

        // Visual Squash/Stretch
        let targetScaleY = 1.0;
        let targetScaleXZ = 1.0;
        const speed = 15;

        // Check if actually falling or jumping
        if (!onGround) {
            if (velocity.y > 0) { // Jumping
                targetScaleY = 1.4; // Stretch
                targetScaleXZ = 0.7; 
                player.material.color.setHex(0x00ff00); // Visual indicator
            } else { // Falling
                targetScaleY = 0.8; // Squash
                targetScaleXZ = 1.2;
                player.material.color.setHex(currentSettings.playerColor.replace('#','0x')); 
            }
        } else {
            // Landed
            player.material.color.set(currentSettings.playerColor);
        }

        player.scale.y = THREE.MathUtils.lerp(player.scale.y, targetScaleY, delta * speed);
        player.scale.x = THREE.MathUtils.lerp(player.scale.x, targetScaleXZ, delta * speed);
        player.scale.z = THREE.MathUtils.lerp(player.scale.z, targetScaleXZ, delta * speed);
        
        // Rotations
        const t = clock.getElapsedTime();
        platforms.forEach(p => { if (p.userData.win) p.rotation.y += delta * 2; });
        hazards.forEach(h => {
            if (h.type === 'rotator') h.mesh.rotation.y += delta * 2; 
        });
    }

    function physics(delta) {
        if(isPaused || gameOver || win) return;

        if (!canWallJump && !onGround) wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
        jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
        dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);
        horizontalLockoutTimer = Math.max(0, horizontalLockoutTimer - delta);

        if(isDashing) {
            dashTimer -= delta;
            if(dashTimer <= 0) {
                isDashing = false;
                dashCooldownTimer = DASH_COOLDOWN;
                velocity.x *= 0.1; velocity.z *= 0.1;
            } else {
                velocity.x = dashDirection.x * DASH_SPEED;
                velocity.z = dashDirection.z * DASH_SPEED;
                velocity.y = 0;
            }
        }

        if (!isDashing && horizontalLockoutTimer === 0) {
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

            const speed = 8; // Slightly faster move speed
            if(dirX !== 0 || dirZ !== 0) {
                let angle = orbitAngleY;
                let sin = Math.sin(angle), cos = Math.cos(angle);
                let moveX = dirZ * sin + dirX * cos;
                let moveZ = dirZ * cos - dirX * sin;
                
                const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
                if(len > 0) { moveX/=len; moveZ/=len; }

                player.position.x += moveX * speed * delta;
                player.position.z += moveZ * speed * delta;
            }
        }

        const pPos = player.position.clone();
        const half = {x:0.5, y:0.5, z:0.5};

        let isTouchingWall = false;
        let currentWallDir = 0;

        for(let w of walls) {
            const wPos = w.position;
            const wSize = {x:w.userData.size.x/2, y:w.userData.size.y/2, z:w.userData.size.z/2};
            
            if (Math.abs(pPos.x - wPos.x) < half.x + wSize.x &&
                Math.abs(pPos.y - wPos.y) < half.y + wSize.y &&
                Math.abs(pPos.z - wPos.z) < half.z + wSize.z) {
                
                let penX = (half.x + wSize.x) - Math.abs(pPos.x - wPos.x);
                let penZ = (half.z + wSize.z) - Math.abs(pPos.z - wPos.z);

                if (penX < penZ) {
                    if (pPos.x > wPos.x) { player.position.x += penX; isTouchingWall = true; currentWallDir = 1; }
                    else { player.position.x -= penX; isTouchingWall = true; currentWallDir = -1; }
                    velocity.x = 0;
                } else {
                    if (pPos.z > wPos.z) { player.position.z += penZ; isTouchingWall = true; currentWallDir = 1; } 
                    else { player.position.z -= penZ; isTouchingWall = true; currentWallDir = -1; }
                    velocity.z = 0;
                }
            }
        }

        if (isTouchingWall && !onGround) {
            canWallJump = true;
            wallJumpDirection = currentWallDir;
            wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
            if (velocity.y < 0) velocity.y = Math.max(velocity.y, -1.5); 
        } else if (!isTouchingWall && canWallJump) {
            canWallJump = false;
        } else if (onGround) {
            canWallJump = false;
        }

        if ((keys['Space'] || keys['Numpad0']) && (onGround || (canWallJump && jumpInputBufferTimer > 0))) {
            velocity.y = canWallJump && !onGround ? WALL_JUMP_POWER : JUMP_POWER;
            
            if (canWallJump && !onGround) {
                velocity.x = -10 * (player.position.x - pPos.x > 0 ? 1 : -1); 
                if (Math.abs(velocity.x) < 1) velocity.z = -10 * (player.position.z - pPos.z > 0 ? 1 : -1);
                horizontalLockoutTimer = WALL_JUMP_LOCKOUT_TIME;
                playSound('jump');
            } else {
                playSound('jump');
            }
            onGround = false;
            jumpInputBufferTimer = 0;
            keys['Space'] = false; 
        }

        velocity.y -= GRAVITY * delta;
        player.position.y += velocity.y * delta;

        if (horizontalLockoutTimer === 0) {
            velocity.x *= 0.9;
            velocity.z *= 0.9;
        }
        player.position.x += velocity.x * delta;
        player.position.z += velocity.z * delta;

        onGround = false;

        for(let pl of platforms) {
            if(pl.userData.moving) {
                const t = clock.getElapsedTime();
                const m = pl.userData.moving;
                if(m.axis === 'x') pl.position.x = m.base + Math.sin(t * m.speed) * m.amplitude;
                if(m.axis === 'z') pl.position.z = m.base + Math.sin(t * m.speed) * m.amplitude;
            }

            const wSize = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
            if (Math.abs(player.position.x - pl.position.x) < half.x + wSize.x &&
                Math.abs(player.position.y - pl.position.y) < half.y + wSize.y &&
                Math.abs(player.position.z - pl.position.z) < half.z + wSize.z) {
                
                if (velocity.y <= 0 && player.position.y > pl.position.y + wSize.y - 0.2) {
                    player.position.y = pl.position.y + wSize.y + half.y;
                    velocity.y = 0;
                    onGround = true;
                    if (pl.userData.win && !win) winStage();
                }
            }
        }

        // FIXED HAZARD COLLISION (Cylinder check for rotation)
        for(let h of hazards) {
            if (h.type === 'rotator') {
                const dist = Math.sqrt(Math.pow(player.position.x - h.mesh.position.x, 2) + Math.pow(player.position.z - h.mesh.position.z, 2));
                // If within radius AND at similar height
                if (Math.abs(player.position.y - h.mesh.position.y) < 0.5 && dist < h.radius) {
                    die();
                }
            }
        }

        if (player.position.y < -10) die();
    }

    function die() {
        if(gameOver || win) return;
        gameOver = true;
        playSound('dash'); 
        showPanel('gameOverPanel');
        isPaused = true;
    }

    function winStage() {
        win = true;
        saveProgress();
        
        // Logic check: Is this the last stage?
        if (currentStage >= TOTAL_STAGES) {
            document.getElementById('winTitle').textContent = "Game Complete! üèÜ";
            document.getElementById('nextLevelBtn').textContent = "Return to Map";
        } else {
            document.getElementById('winTitle').textContent = "Stage Complete! üéâ";
            document.getElementById('nextLevelBtn').textContent = "Next Stage";
        }
        
        showPanel('winPanel');
        isPaused = true;
    }

    function drawMinimap() {
        if (!minimapCtx) return;
        minimapCtx.fillStyle = '#222';
        minimapCtx.fillRect(0, 0, 150, 150);
        const centerX = 75;
        const centerY = 75;
        
        minimapCtx.fillStyle = '#888';
        for(let p of platforms) {
            const relX = (p.position.x - player.position.x) * MAP_SCALE;
            const relZ = (p.position.z - player.position.z) * MAP_SCALE;
            const w = p.userData.size.x * MAP_SCALE;
            const h = p.userData.size.z * MAP_SCALE;
            
            if (p.userData.win) minimapCtx.fillStyle = 'gold';
            else minimapCtx.fillStyle = '#666';
            minimapCtx.fillRect(centerX + relX - w/2, centerY + relZ - h/2, w, h);
        }
        
        minimapCtx.fillStyle = currentSettings.playerColor;
        minimapCtx.beginPath();
        minimapCtx.arc(centerX, centerY, 3, 0, Math.PI*2);
        minimapCtx.fill();
    }

    // --- UI Logic ---
    function showPanel(id) {
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById(id).style.display = 'block';
        document.exitPointerLock();
    }

    function hidePanels() {
        document.getElementById('overlay').style.display = 'none';
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        renderer.domElement.requestPointerLock();
    }

    function resumeGame() {
        isPaused = false;
        hidePanels();
        if (!animationFrameId) animate();
    }

    function handleKeyDown(e) {
        keys[e.code] = true;
        if (e.code === 'Escape') {
            if (document.getElementById('levelSelectPanel').style.display === 'block') return; 
            if (isPaused) resumeGame();
            else { isPaused = true; showPanel('pausePanel'); }
        }
        if (e.code === 'KeyR') loadStage(currentStage);
    }

    function onMouseMove(e) {
        if (isPaused) return;
        orbitAngleY -= e.movementX * dragSensitivity;
        orbitAngleX -= e.movementY * dragSensitivity;
        orbitAngleX = Math.max(0.1, Math.min(Math.PI/2 - 0.1, orbitAngleX));
    }

    function animate() {
        const delta = Math.min(0.05, clock.getDelta());
        if (!isPaused) {
            physics(delta);
            updateAnimations(delta);
            
            const x = player.position.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
            const y = player.position.y + orbitRadius * Math.sin(orbitAngleX);
            const z = player.position.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
            camera.position.set(x, y, z);
            camera.lookAt(player.position);
            
            renderer.render(scene, camera);
            drawMinimap();
        }
        animationFrameId = requestAnimationFrame(animate);
    }

    // --- Init ---
    window.addEventListener('DOMContentLoaded', () => {
        audioCtx = new AudioContext();
        loadSettings();
        init();
        showPanel('levelSelectPanel');

        // Buttons
        document.getElementById('showSettingsBtn').onclick = () => showPanel('settingsPanel');
        document.getElementById('closeSettingsBtn').onclick = () => showPanel('levelSelectPanel');
        document.getElementById('showControlsBtn').onclick = () => showPanel('controlsPanel');
        document.getElementById('closeControlsBtn').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('resumeBtn').onclick = resumeGame;
        document.getElementById('pauseRestartBtn').onclick = () => loadStage(currentStage);
        document.getElementById('menuBtnPause').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('gameOverRestartBtn').onclick = () => loadStage(currentStage);
        document.getElementById('menuBtnLose').onclick = () => showPanel('levelSelectPanel');
        
        document.getElementById('nextLevelBtn').onclick = () => {
            if (currentStage < TOTAL_STAGES) loadStage(currentStage + 1);
            else showPanel('levelSelectPanel'); // Go back to map if done
        };
        document.getElementById('menuBtnWin').onclick = () => showPanel('levelSelectPanel');

        document.getElementById('volumeRange').oninput = (e) => { currentSettings.volume = e.target.value/100; applySettings(); saveSettings(); };
        document.getElementById('playerColorPicker').oninput = (e) => { currentSettings.playerColor = e.target.value; applySettings(); saveSettings(); };
        document.getElementById('cameraDistanceRange').oninput = (e) => { currentSettings.cameraDistance = parseFloat(e.target.value); applySettings(); saveSettings(); };
    });
  </script>
</body>
</html>

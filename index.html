<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Platformer - Wall Jump Challenge</title>
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
  
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: Arial, Helvetica, sans-serif; background: #87ceeb; }
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      color: white;
      z-index: 2;
      user-select: none;
      font-size: 14px;
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
      background: rgba(0,0,0,0.5); 
    }
    .panel {
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 8px;
      color: white;
      max-width: 320px;
      text-align: center;
    }
    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: none;
      background: #222;
      color: white;
      cursor: pointer;
      font-size: 14px;
      margin-top: 12px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    WASD / Arrow keys: move &nbsp;&nbsp; Space: jump &nbsp;&nbsp; **Shift: dash** &nbsp;&nbsp; **Esc: Pause** &nbsp;&nbsp; R: respawn<br>
    Mouse move: rotate camera<br>
    **Challenge:** Use the wall jump (jump while sliding on a wall) to climb the tower.
  </div>
  <div id="overlay">
    <div class="panel" id="startPanel">
      <h2 style="margin:0 0 8px 0">3D Platformer ‚Äî Wall Climb Challenge</h2>
      <div>Use WASD to move. Use **Shift** to dash. Click 'Start' to begin.</div>
      <button id="startBtn">Start</button>
    </div>
    <div class="panel" id="winPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">You win! üéâ</h2>
      <button id="restartBtn">Play again</button>
    </div>
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0; color:#f33;">Game Over</h2>
      <div>You hit a spike or fell! Try again.</div>
      <button id="gameOverRestartBtn">Restart</button>
    </div>
    <div class="panel" id="pausePanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">Game Paused</h2>
      <button id="resumeBtn">Resume (Esc)</button>
      <button id="pauseRestartBtn">Restart Level</button>
    </div>
  </div>
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  
  <script>
    // Since we are using the global CDN, THREE is globally available.

    let scene, camera, renderer;
    let player, platforms = [], spikes = [], walls = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;
    let isPaused = true; 

    // --- Physics & Wall Jump Logic ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.1;
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.15;
    let jumpInputBufferTimer = 0;
    
    const WALL_JUMP_LOCKOUT_TIME = 0.2; 
    let horizontalLockoutTimer = 0; 

    // --- Dash Logic ---
    let isDashing = false;
    const DASH_SPEED = 20;
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    const DASH_COOLDOWN = 0.7; 
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3();
    const defaultPlayerColor = 0xff8c00;
    const dashPlayerColor = 0x00ffff;
    
    // --- Gameplay Adjustments ---
    const JUMP_POWER = 7.0;
    const WALL_JUMP_POWER = 8.5;

    // Orbit camera params
    let orbitRadius = 12;
    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let dragSensitivity = 0.005;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.1;

    // Audio context and music
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let backgroundMusic = null;

    const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00, B4 = 493.88, C5 = 523.25, D5 = 587.33;

    function playMusic() {
      if (!audioCtx) return;
      if (backgroundMusic) return;

      const tempo = 110; 
      const quarterNote = 60 / tempo;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.05, audioCtx.currentTime); 
      gain.connect(audioCtx.destination);

      let sequence = [
        { note: C4, duration: quarterNote }, { note: E4, duration: quarterNote },
        { note: G4, duration: quarterNote }, { note: C5, duration: quarterNote },
        { note: A4, duration: quarterNote * 2 }, { note: F4, duration: quarterNote * 2 },
        { note: G4, duration: quarterNote * 1 }, { note: E4, duration: quarterNote * 1 },
        { note: D4, duration: quarterNote }, { note: F4, duration: quarterNote },
        { note: A4, duration: quarterNote }, { note: D5, duration: quarterNote },
        { note: B4, duration: quarterNote * 2 }, { note: G4, duration: quarterNote * 2 },
        { note: E4, duration: quarterNote * 1 }, { note: C4, duration: quarterNote * 1 }
      ];
      
      let stepIndex = 0;
      
      function playNextNote() {
        if (backgroundMusic) clearTimeout(backgroundMusic);
        if (isPaused || gameOver || win) return; 
        
        const seq = sequence[stepIndex % sequence.length];
        const now = audioCtx.currentTime;

        if (seq.note > 0) {
          let osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(seq.note, now);
          osc.connect(gain);
          osc.start(now);
          osc.stop(now + seq.duration * 0.9);
        }
        
        stepIndex++;
        
        const nextTime = now + seq.duration;
        const delay = (nextTime - audioCtx.currentTime) * 1000;
        
        if (delay > 0) {
            backgroundMusic = setTimeout(playNextNote, delay);
        } else {
            backgroundMusic = setTimeout(playNextNote, 1);
        }
      }
      playNextNote();
    }

    function stopMusic() {
        if(backgroundMusic) {
            clearTimeout(backgroundMusic);
            backgroundMusic = null;
        }
    }

    function playSound(type) {
      if(!audioCtx || isPaused || gameOver || win) return;
      
      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gainNode = audioCtx.createGain();
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(2000, now); 

      osc.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      switch(type) {
        case 'jump':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(400, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.2, now + 0.04);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.18);
          break;
        case 'walljump':
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(600, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.25, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.25);
          break;
        case 'dash':
          osc.type = 'square';
          osc.frequency.setValueAtTime(800, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.3, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
          break;
        case 'win':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(700, now); 
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(0.4, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
          break;
        case 'gameover':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(150, now);
          gainNode.gain.setValueAtTime(0.4, now);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
          break;
      }

      osc.start(now);
      osc.stop(now + 0.5);
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas-holder').appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 50, 0);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(10, 20, 10);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024,1024);
      scene.add(dir);

      const geom = new THREE.BoxGeometry(1,1,1);
      const mat = new THREE.MeshStandardMaterial({color:defaultPlayerColor});
      player = new THREE.Mesh(geom, mat);
      player.castShadow = true;
      player.receiveShadow = true;
      player.position.set(0,2,0);
      scene.add(player);

      // --- Level Design ---
      addPlatform(0, -1, 0, 20, 1, 20, 0x556b2f);
      const platformHeight = 0.5;
      let zPos = -2, yPos = 0;

      // 1. Initial Jump Test
      zPos += 4 + 1.5;
      addPlatform(0, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
      zPos += 5 + 1;

      // 2. Climbing Wall 1 (Intro to Wall Jump)
      yPos += 1.2;
      let plat1 = addPlatform(-5, yPos, zPos, 4, platformHeight, 5, 0x8b4513);
      const wallMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
      const tallWallGeometry = new THREE.BoxGeometry(0.5, 8, 8);
      let tallLeftWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallLeftWall.position.set(plat1.position.x - 1.5, plat1.position.y + 4, plat1.position.z);
      scene.add(tallLeftWall);
      walls.push(tallLeftWall);
      let tallRightWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
      tallRightWall.position.set(plat1.position.x - 3.5, plat1.position.y + 4, plat1.position.z);
      scene.add(tallRightWall);
      walls.push(tallRightWall);
      
      // Dash jump target 
      zPos += 5 + 2;
      yPos += 2.5;
      addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
      
      // 3. Low Ceiling Dash Section 
      yPos += 1;
      zPos += 5 + 1;
      addPlatform(10, yPos, zPos, 6, platformHeight, 3, 0x8b4513);
      addPlatform(10, yPos + 1.5, zPos, 6, 0.2, 3, 0x777777); 

      yPos += 0.5;
      zPos += 5;
      addPlatform(10, yPos, zPos, 5, platformHeight, 5, 0x8b4513);

      // 4. Moving Platform Challenge with Spike
      yPos += 1;
      zPos += 5 + 2;
      let movingPlat = addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x1e90ff);
      movingPlat.userData.moving = {amplitude:4, speed:0.8, axis:'x', base: movingPlat.position.x};
      const spikeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
      const spikeMaterial = new THREE.MeshStandardMaterial({color: 0x666666});
      let spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
      spike.castShadow = true;
      spike.receiveShadow = true;
      spike.position.set(movingPlat.position.x, movingPlat.position.y + platformHeight/2 + 0.5, movingPlat.position.z);
      scene.add(spike);
      spikes.push({mesh: spike, platform: movingPlat}); 

      // --- 5. WALL CLIMB TOWER SECTION ---
      const towerHeight = 12; 
      const towerWidth = 5;  
      yPos = movingPlat.position.y + platformHeight/2 + 0.01;
      zPos += 8; 
      let towerEntrance = addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
      let backWall = new THREE.Mesh(new THREE.BoxGeometry(towerWidth + 2, towerHeight, 0.5), wallMaterial);
      backWall.position.set(towerEntrance.position.x, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z + 2.5);
      scene.add(backWall); walls.push(backWall);
      let leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
      leftWall.position.set(towerEntrance.position.x - (towerWidth/2) - 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
      scene.add(leftWall); walls.push(leftWall);
      let rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
      rightWall.position.set(towerEntrance.position.x + (towerWidth/2) + 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
      scene.add(rightWall); walls.push(rightWall);
      yPos += towerHeight + 0.5;
      addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x556b2f); 

      // --- 6. Final Jump to Win ---
      yPos += 3;
      zPos += 5;
      const winP = addPlatform(5, yPos, zPos, 6, 0.5, 6, 0xffff00);
      winP.userData.win = true;


      window.addEventListener('resize', onWindowResize);
      window.addEventListener('keydown', e => {
        keys[e.code] = true;
        
        if (e.code === 'Escape' && !gameOver && !win) {
            isPaused ? resumeGame() : pauseGame();
            e.preventDefault(); 
            return;
        }

        if(isPaused || gameOver || win) return;

        if(e.code === 'Space' || keys['Numpad0']){
          jumpInputBufferTimer = JUMP_INPUT_BUFFER_TIME;
        }
        if(e.code === 'ShiftLeft' && dashCooldownTimer <= 0 && !isDashing){
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;
            
            let angle = orbitAngleY;
            let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
            let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
            
            dashDirection.set(0,0,0);
            if(dirX !== 0 || dirZ !== 0) {
                dashDirection.addScaledVector(forward, dirZ);
                dashDirection.addScaledVector(right, dirX);
                dashDirection.normalize();
            } else {
                dashDirection.copy(forward);
            }

            isDashing = true;
            dashTimer = DASH_DURATION;
            player.material.color.setHex(dashPlayerColor);
            playSound('dash');
            
            velocity.y = Math.min(velocity.y, 0.5); 
        }
      });
      window.addEventListener('keyup', e => keys[e.code] = false);

      renderer.domElement.addEventListener('mousemove', onMouseMove);

      cameraTarget.copy(player.position);
      cameraTarget.y += 0.5;
    }

    function addPlatform(x,y,z,w,h,d,color) {
      const g = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.MeshStandardMaterial({color: color});
      const mesh = new THREE.Mesh(g,m);
      mesh.receiveShadow = true;
      mesh.position.set(x,y,z);
      mesh.userData.size = {x:w,y:h,z:d};
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) <= (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) <= (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) <= (aSize.z + bSize.z);
    }

    function handleJump(isWallJump, wallDir) {
        if(isWallJump) {
            velocity.y = WALL_JUMP_POWER;
            velocity.x = -8 * wallDir;
            velocity.z = 0; 
            playSound('walljump');
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
            horizontalLockoutTimer = WALL_JUMP_LOCKOUT_TIME; 

        } else {
            velocity.y = JUMP_POWER;
            playSound('jump');
        }
        onGround = false;
        jumpInputBufferTimer = 0;
    }

    function physics(delta) {
        if(gameOver || win || isPaused) return;

        // Update timers
        if (!canWallJump && !onGround) {
            wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
        }
        jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
        dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);
        horizontalLockoutTimer = Math.max(0, horizontalLockoutTimer - delta);

        // --- Handle Dash Logic --- 
        if(isDashing) {
            dashTimer -= delta;
            if(dashTimer <= 0) {
                isDashing = false;
                dashCooldownTimer = DASH_COOLDOWN;
                player.material.color.setHex(defaultPlayerColor);
                velocity.x *= 0.1; 
                velocity.z *= 0.1;
            } else {
                velocity.x = dashDirection.x * DASH_SPEED;
                velocity.z = dashDirection.z * DASH_SPEED;
                velocity.y = 0; 
            }
        } 
        
        // 1. Horizontal Movement (Only runs if NOT dashing AND NOT locked out) 
        if (!isDashing && horizontalLockoutTimer === 0) { 
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

            const speed = 6;
            if(dirX !== 0 || dirZ !== 0) {
                let angle = orbitAngleY;
                let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
                let moveDir = new THREE.Vector3();
                moveDir.addScaledVector(forward, dirZ);
                moveDir.addScaledVector(right, dirX);
                moveDir.normalize();
                
                player.position.addScaledVector(moveDir, speed * delta);
            }
        }
        
        const pPos = player.position.clone();
        const half = {x:0.5,y:0.5,z:0.5};
        
        // 2. Wall detection for wall jump (Standard checks)
        let isTouchingWall = false;
        let currentWallDir = 0;

        for(let w of walls){
            const wPos = w.position;
            const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
            if(aabbIntersect(pPos, half, wPos, wSize)){
                let diffX = pPos.x - wPos.x;
                let diffZ = pPos.z - wPos.z;
                
                if (wSize.z < wSize.x) { 
                    if(Math.abs(diffZ) > 0.01){
                        isTouchingWall = true;
                        currentWallDir = diffZ > 0 ? 1 : -1;
                    }
                } else { 
                    if(Math.abs(diffX) > 0.01){
                        isTouchingWall = true;
                        currentWallDir = diffX > 0 ? 1 : -1;
                    }
                }

                if (isTouchingWall) break;
            }
        }

        if (isTouchingWall && !onGround) {
            canWallJump = true;
            wallJumpDirection = currentWallDir;
            wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
            
            if (velocity.y < 0) {
                velocity.y = Math.max(velocity.y, -1.5);
            }
        } else if (!isTouchingWall && canWallJump) {
            canWallJump = false;
        } else if (onGround) {
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
        }
        
        // 3. Jump Execution
        const isJumpPressed = (keys['Space'] || keys['Numpad0']);
        const canJump = onGround && isJumpPressed;
        const canWallJumpNow = isTouchingWall && jumpInputBufferTimer > 0;
        const canCoyoteJump = wallJumpCoyoteTimer > 0 && isJumpPressed && !onGround && !isTouchingWall;

        if(canJump){
            handleJump(false, 0);
        } else if(canWallJumpNow){
            handleJump(true, currentWallDir);
        } else if(canCoyoteJump){
            handleJump(true, wallJumpDirection); 
        }

        // Apply Gravity
        velocity.y -= 9.8 * delta;

        // Apply velocity X/Z (from wall jump or dash)
        player.position.x += velocity.x * delta;
        
        // WALL JUMP FIX: Only damp horizontal movement if NOT in lockout
        if (horizontalLockoutTimer === 0) {
             velocity.x *= 0.8; 
        }

        player.position.z += velocity.z * delta; 
        if (horizontalLockoutTimer === 0) {
             velocity.z *= 0.8;
        }


        player.position.y += velocity.y * delta;

        onGround = false;

        // 4. Platform Collision (Standard checks)
        for(let pl of platforms) {
            if(pl.userData.moving){
                const t = performance.now()/1000;
                const m = pl.userData.moving;
                if(m.axis === 'x') pl.position.x = m.base + Math.sin(t*m.speed) * m.amplitude;
                else pl.position.z = m.base + Math.sin(t*m.speed) * m.amplitude;
            }
            const size = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
            if(aabbIntersect(pPos, half, pl.position, size)) {
                const playerBottom = player.position.y - 0.5;
                const plTop = pl.position.y + size.y;
                const penetration = plTop - playerBottom;
                if(velocity.y <= 0 && penetration > 0 && Math.abs(player.position.x - pl.position.x) < (size.x+half.x) && Math.abs(player.position.z - pl.position.z) < (size.z+half.z)){
                    player.position.y += penetration + 0.001;
                    velocity.y = 0;
                    onGround = true;
                    velocity.x = 0;
                    velocity.z = 0;

                    if(pl.userData.moving){
                        player.position.x += (pl.position.x - (pl.userData._lastX ?? pl.position.x));
                        player.position.z += (pl.position.z - (pl.userData._lastZ ?? pl.position.z));
                    }

                    if(pl.userData.win && !win){
                        win = true;
                        playSound('win');
                        stopMusic();
                        showWin();
                    }
                    
                    canWallJump = false;
                    wallJumpCoyoteTimer = 0;
                    dashCooldownTimer = 0; 
                }
                pl.userData._lastX = pl.position.x;
                pl.userData._lastZ = pl.position.z;
            }
        }

        // 5. Collide with walls (Robust resolution)
        for(let w of walls){
            const wPos = w.position;
            const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
            if(aabbIntersect(player.position, half, wPos, wSize)){
                let diffX = player.position.x - wPos.x;
                let diffZ = player.position.z - wPos.z;
                
                const penX = (wSize.x + half.x) - Math.abs(diffX);
                const penZ = (wSize.z + half.z) - Math.abs(diffZ); 

                if(penX < penZ) {
                    if(diffX > 0){
                        player.position.x += penX + 0.01; 
                        velocity.x = Math.max(velocity.x, 0); 
                    } else {
                        player.position.x -= penX + 0.01;
                        velocity.x = Math.min(velocity.x, 0);
                    }
                } else {
                    if(diffZ > 0){
                        player.position.z += penZ + 0.01;
                        velocity.z = Math.max(velocity.z, 0);
                    } else {
                        player.position.z -= penZ + 0.01;
                        velocity.z = Math.min(velocity.z, 0);
                    }
                }
            }
        }

        // 6. Check spikes collision (game over)
        for(let s of spikes){
            const mesh = s.mesh;
            if(!mesh || !mesh.position) continue; // Safety check
            
            const sp = mesh.position; 
            if(player.position.distanceTo(sp) < 0.7){
                triggerGameOver();
                break;
            }
        }

        // Keep player above the floor plane
        if(player.position.y < -5){
            triggerGameOver();
        }
    }
    

    function triggerGameOver() {
      if(gameOver) return;
      gameOver = true;
      stopMusic();
      playSound('gameover');
      document.getElementById('gameOverPanel').style.display = '';
      document.getElementById('overlay').style.display = '';
      document.getElementById('startPanel').style.display = 'none';
      document.getElementById('winPanel').style.display = 'none';
      document.getElementById('pausePanel').style.display = 'none';
      document.exitPointerLock();
    }

    function updateCamera() {
      cameraTarget.x = THREE.MathUtils.lerp(cameraTarget.x, player.position.x, CAMERA_SMOOTHING);
      cameraTarget.y = THREE.MathUtils.lerp(cameraTarget.y, player.position.y + 0.5, CAMERA_SMOOTHING);
      cameraTarget.z = THREE.MathUtils.lerp(cameraTarget.z, player.position.z, CAMERA_SMOOTHING);
      
      orbitAngleX = Math.min(Math.max(0.1, orbitAngleX), Math.PI/2 - 0.1);
      const x = cameraTarget.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
      const y = cameraTarget.y + orbitRadius * Math.sin(orbitAngleX);
      const z = cameraTarget.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
      camera.position.set(x, y, z);
      camera.lookAt(cameraTarget);
    }

    let animationFrameId = null;
    function animate() {
      if (isPaused || gameOver || win) {
        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        return;
      }

      const delta = Math.min(0.05, clock.getDelta());
      physics(delta);
      updateCamera();
      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    function pauseGame() {
        if (isPaused || gameOver || win) return;
        isPaused = true;
        stopMusic();
        document.getElementById('pausePanel').style.display = '';
        document.getElementById('overlay').style.display = '';
        document.exitPointerLock(); 
    }

    function resumeGame() {
        if (!isPaused) return;
        isPaused = false;
        playMusic();
        document.getElementById('pausePanel').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        
        if (animationFrameId === null) {
            clock.start();
            animate();
        }
        renderer.domElement.requestPointerLock();
    }

    function respawn() {
      player.position.set(0, 2, 0);
      velocity.set(0,0,0);
      win = false;
      gameOver = false;
      isPaused = false;
      canWallJump = false;
      wallJumpDirection = 0;
      wallJumpCoyoteTimer = 0;
      jumpInputBufferTimer = 0;
      isDashing = false;
      dashCooldownTimer = 0;
      horizontalLockoutTimer = 0; 
      player.material.color.setHex(defaultPlayerColor);
      
      document.getElementById('winPanel').style.display = 'none';
      document.getElementById('gameOverPanel').style.display = 'none';
      document.getElementById('startPanel').style.display = 'none';
      document.getElementById('pausePanel').style.display = 'none';
      document.getElementById('overlay').style.display = 'none';

      clock.start();
      playMusic();
      animate();
      renderer.domElement.requestPointerLock();
    }

    function showWin() {
      isPaused = true;
      stopMusic();
      document.getElementById('winPanel').style.display = '';
      document.getElementById('overlay').style.display = '';
      document.getElementById('startPanel').style.display = 'none';
      document.getElementById('gameOverPanel').style.display = 'none';
      document.getElementById('pausePanel').style.display = 'none';
      document.exitPointerLock();
    }

    function onMouseMove(e) {
      if (isPaused || gameOver || win) return;
      
      let deltaX = e.movementX;
      let deltaY = e.movementY;

      if (deltaX === undefined || deltaY === undefined) return; 
      
      orbitAngleY -= deltaX * dragSensitivity;
      orbitAngleX -= deltaY * dragSensitivity;
    }

    window.addEventListener('DOMContentLoaded', () => {
      audioCtx = new AudioContext();
      init();

      document.getElementById('startBtn').addEventListener('click', () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        isPaused = false;
        document.getElementById('overlay').style.display = 'none';
        clock.start();
        playMusic();
        animate();
        renderer.domElement.requestPointerLock(); 
      });
      document.getElementById('resumeBtn').addEventListener('click', () => resumeGame());
      document.getElementById('pauseRestartBtn').addEventListener('click', () => respawn());
      document.getElementById('restartBtn').addEventListener('click', () => respawn());
      document.getElementById('gameOverRestartBtn').addEventListener('click', () => respawn());
      
      window.addEventListener('keydown', e => {
        if(e.code === 'KeyR' && (gameOver || win || isPaused)) respawn();
      });
      
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== renderer.domElement && !gameOver && !win && !isPaused) {
          pauseGame();
        }
      });
    });
</script>
</body>
</html>

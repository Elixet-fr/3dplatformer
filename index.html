function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.getElementById('canvas-holder').appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
  hemi.position.set(0, 50, 0);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(10, 20, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(dir);

  const geom = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshStandardMaterial({color:defaultPlayerColor});
  player = new THREE.Mesh(geom, mat);
  player.castShadow = true;
  player.receiveShadow = true;
  player.position.set(0,2,0);
  scene.add(player);

  // Base ground platform
  addPlatform(0, -1, 0, 20, 1, 20, 0x556b2f);

  // Platform params
  const platformWidth = 5;
  const platformHeight = 0.5;
  let zPos = -2;
  let yPos = 0;

  // Spike geometry - pyramid
  const spikeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
  const spikeMaterial = new THREE.MeshStandardMaterial({color: 0x666666});

  // Wall geometry
  const wallMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
  const tallWallGeometry = new THREE.BoxGeometry(0.5, 8, 8);
  const longWallGeometry = new THREE.BoxGeometry(10, 10, 0.5); // Para a torre de pulo (definição mantida)

  // --- Level Design ---

  // 1. Initial Jump Test
  zPos += 4 + 1.5;
  addPlatform(0, yPos, zPos, platformWidth, platformHeight, 5, 0x8b4513);
  zPos += 5 + 1;

  // 2. Climbing Wall 1
  yPos += 1.2;
  let plat1 = addPlatform(-5, yPos, zPos, 4, platformHeight, 5, 0x8b4513);
  
  let tallLeftWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
  tallLeftWall.position.set(plat1.position.x - 1.5, plat1.position.y + 4, plat1.position.z);
  scene.add(tallLeftWall);
  walls.push(tallLeftWall);

  let tallRightWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
  tallRightWall.position.set(plat1.position.x - 3.5, plat1.position.y + 4, plat1.position.z);
  scene.add(tallRightWall);
  walls.push(tallRightWall);
  
  // Dash jump target 
  zPos += 5 + 2;
  yPos += 2.5;
  addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
  
  // 3. Low Ceiling Dash Section 
  yPos += 1;
  zPos += 5 + 1;
  let lowPlat = addPlatform(10, yPos, zPos, 6, platformHeight, 3, 0x8b4513);

  // Low ceiling above the platform
  addPlatform(10, yPos + 1.5, zPos, 6, 0.2, 3, 0x777777); 

  yPos += 0.5;
  zPos += 5;
  addPlatform(10, yPos, zPos, 5, platformHeight, 5, 0x8b4513);

  // 4. Moving Platform Challenge with Spike
  yPos += 1;
  zPos += 5 + 2;
  let movingPlat = addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x1e90ff);
  movingPlat.userData.moving = {amplitude:4, speed:0.8, axis:'x', base: movingPlat.position.x};

  // Spike on moving platform
  let spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
  spike.castShadow = true;
  spike.receiveShadow = true;
  spike.position.set(movingPlat.position.x, movingPlat.position.y + platformHeight/2 + 0.5, movingPlat.position.z);
  scene.add(spike);
  spikes.push({mesh: spike, platform: movingPlat});

  // --- 5. WALL CLIMB TOWER SECTION (New) ---
  const towerHeight = 12; // Altura da torre para o desafio
  const towerWidth = 5;  // Distância horizontal para pular (Wall Jump)
  
  // Reset Y position for new platform entry
  yPos = movingPlat.position.y + platformHeight/2 + 0.01;
  zPos += 8; // Move para a nova seção

  // Plataforma de entrada na torre
  let towerEntrance = addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
  
  // Parede Traseira (fundo da torre)
  let backWall = new THREE.Mesh(new THREE.BoxGeometry(towerWidth + 2, towerHeight, 0.5), wallMaterial);
  backWall.position.set(towerEntrance.position.x, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z + 2.5);
  scene.add(backWall);
  walls.push(backWall);

  // Parede Esquerda
  let leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
  leftWall.position.set(towerEntrance.position.x - (towerWidth/2) - 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
  scene.add(leftWall);
  walls.push(leftWall);

  // Parede Direita
  let rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
  rightWall.position.set(towerEntrance.position.x + (towerWidth/2) + 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
  scene.add(rightWall);
  walls.push(rightWall);
  
  // Plataforma de Saída (no topo da torre)
  yPos += towerHeight + 0.5;
  let towerExit = addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x556b2f); 

  // --- 6. Final Jump to Win ---
  
  // A plataforma de vitória deve estar bem acima da plataforma de saída da torre
  yPos += 3;
  zPos += 5;
  const winP = addPlatform(5, yPos, zPos, 6, 0.5, 6, 0xffff00);
  winP.userData.win = true;


  window.addEventListener('resize', onWindowResize);
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if(e.code === 'Space' || keys['Numpad0']){
      jumpInputBufferTimer = JUMP_INPUT_BUFFER_TIME;
    }
    if(e.code === 'ShiftLeft' && dashCooldownTimer <= 0 && !isDashing){
        let dirX = 0, dirZ = 0;
        if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
        if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
        if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
        if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;
        
        let angle = orbitAngleY;
        let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
        let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
        
        dashDirection.set(0,0,0);
        if(dirX !== 0 || dirZ !== 0) {
            dashDirection.addScaledVector(forward, dirZ);
            dashDirection.addScaledVector(right, dirX);
            dashDirection.normalize();
        } else {
            dashDirection.copy(forward);
        }

        isDashing = true;
        dashTimer = DASH_DURATION;
        player.material.color.setHex(dashPlayerColor);
        playSound('dash');
        
        velocity.y = Math.min(velocity.y, 0.5); 
    }
  });
  window.addEventListener('keyup', e => keys[e.code] = false);

  renderer.domElement.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mouseup', onMouseUp);
  window.addEventListener('mousemove', onMouseMove);
}

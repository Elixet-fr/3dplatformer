<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Platformer - Wall Jump Challenge</title>
  
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
  
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { font-family: Arial, Helvetica, sans-serif; background: #87ceeb; }
    #ui {
      position: absolute;
      left: 16px;
      top: 16px;
      color: white;
      z-index: 2;
      user-select: none;
      font-size: 14px;
      text-shadow: 1px 1px 2px black;
    }
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3;
      background: rgba(0,0,0,0.5); 
    }
    .panel {
      background: rgba(0,0,0,0.8);
      padding: 20px;
      border-radius: 8px;
      color: white;
      max-width: 320px;
      text-align: center;
      margin: 10px;
    }
    .settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 15px;
        text-align: left;
    }
    .settings-grid label {
        grid-column: 1 / 2;
        align-self: center;
    }
    .settings-grid input[type="range"], .settings-grid input[type="color"] {
        grid-column: 2 / 3;
        width: 100%;
        margin: 0;
    }
    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: none;
      background: #222;
      color: white;
      cursor: pointer;
      font-size: 14px;
      margin: 12px 6px 0 6px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="stageInfo">Stage: 1 / 3</div>
    WASD / Arrow keys: move &nbsp;&nbsp; Space: jump &nbsp;&nbsp; **Shift: dash** &nbsp;&nbsp; **Esc: Pause** &nbsp;&nbsp; G: Settings<br>
    Mouse move: rotate camera &nbsp;&nbsp; **R: respawn**
  </div>
  <div id="overlay">
    <div class="panel" id="startPanel">
      <h2 style="margin:0 0 8px 0">3D Platformer ‚Äî Wall Climb Challenge</h2>
      <div>Use WASD to move. Use **Shift** to dash. Click 'Start' to begin.</div>
      <button id="startBtn">Start</button>
      <button id="showSettingsBtn">Settings (G)</button>
    </div>
    
    <div class="panel" id="settingsPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">Settings</h2>
      
      <div class="settings-grid">
        <label for="volumeRange">Music Volume</label>
        <input type="range" id="volumeRange" min="0" max="100" value="50">
        
        <label for="playerColorPicker">Player Color</label>
        <input type="color" id="playerColorPicker" value="#FF8C00">
        
        <label for="cameraDistanceRange">Camera Distance</label>
        <input type="range" id="cameraDistanceRange" min="5" max="20" value="12">
        <span id="cameraDistanceValue" style="grid-column: 2 / 3; font-size: 12px;">12m</span>
      </div>
      
      <button id="closeSettingsBtn">Close</button>
    </div>
    
    <div class="panel" id="winPanel" style="display:none;">
      <h2 id="winTitle" style="margin:0 0 8px 0">Stage Complete! üéâ</h2>
      <button id="restartBtn">Play Next Stage</button>
    </div>
    
    <div class="panel" id="gameOverPanel" style="display:none;">
      <h2 style="margin:0 0 8px 0; color:#f33;">Game Over</h2>
      <div>You hit a spike or fell! Try again.</div>
      <button id="gameOverRestartBtn">Restart Stage</button>
    </div>
    
    <div class="panel" id="pausePanel" style="display:none;">
      <h2 style="margin:0 0 8px 0">Game Paused</h2>
      <button id="resumeBtn">Resume (Esc)</button>
      <button id="pauseRestartBtn">Restart Level</button>
      <button id="pauseSettingsBtn">Settings (G)</button>
    </div>
  </div>
  <div id="canvas-holder"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  
  <script>
    // --- Global Variables (Game State) ---
    let scene, camera, renderer;
    let player, platforms = [], spikes = [], walls = [], hazards = [];
    let velocity = new THREE.Vector3();
    let onGround = false;
    let keys = {};
    let clock = new THREE.Clock();
    let win = false;
    let gameOver = false;
    let isPaused = true; 
    let animationFrameId = null;

    // --- LEVEL MANAGEMENT ---
    let currentStage = 1;
    const TOTAL_STAGES = 3; 

    // --- Loaded Settings ---
    let currentSettings = {
        volume: 0.5, 
        playerColor: '#FF8C00',
        cameraDistance: 12,
    };

    // --- Physics & Wall Jump Logic ---
    let canWallJump = false;
    let wallJumpDirection = 0;
    const WALL_JUMP_COYOTE_TIME = 0.1;
    let wallJumpCoyoteTimer = 0;
    const JUMP_INPUT_BUFFER_TIME = 0.15;
    let jumpInputBufferTimer = 0;
    const WALL_JUMP_LOCKOUT_TIME = 0.2; 
    let horizontalLockoutTimer = 0; 

    // --- Dash Logic ---
    let isDashing = false;
    const DASH_SPEED = 20;
    const DASH_DURATION = 0.15;
    let dashTimer = 0;
    const DASH_COOLDOWN = 0.7; 
    let dashCooldownTimer = 0;
    let dashDirection = new THREE.Vector3();
    const dashPlayerColor = 0x00ffff;
    
    // --- Gameplay Adjustments ---
    const JUMP_POWER = 7.0;
    const WALL_JUMP_POWER = 8.5;

    // Orbit camera params
    let orbitAngleX = Math.PI / 4;
    let orbitAngleY = 0;
    let dragSensitivity = 0.005;
    const cameraTarget = new THREE.Vector3();
    const CAMERA_SMOOTHING = 0.1;
    let orbitRadius; // Set by settings

    // Audio context and music
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let backgroundMusic = null;
    let musicGainNode = null; 

    const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00, B4 = 493.88, C5 = 523.25, D5 = 587.33;

    // --- Settings Persistence Functions ---

    function loadSettings() {
        const savedSettings = localStorage.getItem('platformerSettings');
        const savedStage = localStorage.getItem('platformerCurrentStage');
        
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                currentSettings.volume = parseFloat(settings.volume || 0.5);
                currentSettings.playerColor = settings.playerColor || '#FF8C00';
                currentSettings.cameraDistance = parseFloat(settings.cameraDistance || 12);
            } catch (e) {
                console.error("Error loading settings from localStorage:", e);
            }
        }
        
        // Load Stage
        if (savedStage) {
            currentStage = parseInt(savedStage) || 1;
        }

        // Apply loaded settings to the UI (if elements exist)
        if (document.getElementById('volumeRange')) {
            document.getElementById('volumeRange').value = currentSettings.volume * 100;
        }
        if (document.getElementById('playerColorPicker')) {
            document.getElementById('playerColorPicker').value = currentSettings.playerColor;
        }
        if (document.getElementById('cameraDistanceRange')) {
            document.getElementById('cameraDistanceRange').value = currentSettings.cameraDistance;
            document.getElementById('cameraDistanceValue').textContent = currentSettings.cameraDistance.toFixed(0) + 'm';
        }
        document.getElementById('stageInfo').textContent = `Stage: ${currentStage} / ${TOTAL_STAGES}`;
    }

    function saveSettings() {
        localStorage.setItem('platformerSettings', JSON.stringify(currentSettings));
    }
    
    function saveStage() {
        localStorage.setItem('platformerCurrentStage', currentStage);
        document.getElementById('stageInfo').textContent = `Stage: ${currentStage} / ${TOTAL_STAGES}`;
    }

    function applySettings() {
        // Apply Volume
        if (musicGainNode) {
            musicGainNode.gain.setTargetAtTime(currentSettings.volume * 0.5, audioCtx.currentTime, 0.05); 
        }

        // Apply Player Color
        if (player && !isDashing) { 
            player.material.color.set(currentSettings.playerColor);
        }

        // Apply Camera Distance
        orbitRadius = currentSettings.cameraDistance;
    }


    // --- Audio Functions ---

    function playMusic() {
      if (!audioCtx) return;
      if (backgroundMusic) return;

      if (!musicGainNode) {
        musicGainNode = audioCtx.createGain();
        musicGainNode.gain.setValueAtTime(currentSettings.volume * 0.5, audioCtx.currentTime); 
        musicGainNode.connect(audioCtx.destination);
      }

      const tempo = 110; 
      const quarterNote = 60 / tempo;

      let sequence = [
        { note: C4, duration: quarterNote }, { note: E4, duration: quarterNote },
        { note: G4, duration: quarterNote }, { note: C5, duration: quarterNote },
        { note: A4, duration: quarterNote * 2 }, { note: F4, duration: quarterNote * 2 },
        { note: G4, duration: quarterNote * 1 }, { note: E4, duration: quarterNote * 1 },
        { note: D4, duration: quarterNote }, { note: F4, duration: quarterNote },
        { note: A4, duration: quarterNote }, { note: D5, duration: quarterNote },
        { note: B4, duration: quarterNote * 2 }, { note: G4, duration: quarterNote * 2 },
        { note: E4, duration: quarterNote * 1 }, { note: C4, duration: quarterNote * 1 }
      ];
      
      let stepIndex = 0;
      
      function playNextNote() {
        if (backgroundMusic) clearTimeout(backgroundMusic);
        if (isPaused || gameOver || win) return; 
        
        const seq = sequence[stepIndex % sequence.length];
        const now = audioCtx.currentTime;

        if (seq.note > 0) {
          let osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(seq.note, now);
          osc.connect(musicGainNode); 
          osc.start(now);
          osc.stop(now + seq.duration * 0.9);
        }
        
        stepIndex++;
        
        const nextTime = now + seq.duration;
        const delay = (nextTime - audioCtx.currentTime) * 1000;
        
        if (delay > 0) {
            backgroundMusic = setTimeout(playNextNote, delay);
        } else {
            backgroundMusic = setTimeout(playNextNote, 1);
        }
      }
      playNextNote();
    }

    function stopMusic() {
        if(backgroundMusic) {
            clearTimeout(backgroundMusic);
            backgroundMusic = null;
        }
    }

    function playSound(type) {
      if(!audioCtx || isPaused || gameOver || win) return;
      
      const now = audioCtx.currentTime;
      let osc = audioCtx.createOscillator();
      let gainNode = audioCtx.createGain();
      
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.setValueAtTime(2000, now); 

      osc.connect(filter);
      filter.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      let maxGain = currentSettings.volume * 0.5; 

      switch(type) {
        case 'jump':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(400, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(maxGain * 0.4, now + 0.04);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.18);
          break;
        case 'walljump':
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(600, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(maxGain * 0.5, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.25);
          break;
        case 'dash':
          osc.type = 'square';
          osc.frequency.setValueAtTime(800, now);
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(maxGain * 0.6, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
          break;
        case 'win':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(700, now); 
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(maxGain * 0.8, now + 0.05);
          gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
          break;
        case 'gameover':
          osc.type = 'sine';
          osc.frequency.setValueAtTime(150, now);
          gainNode.gain.setValueAtTime(maxGain * 0.8, now);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
          break;
      }

      osc.start(now);
      osc.stop(now + 0.5);
    }

    // --- Game Setup and Level Design ---

    function clearScene() {
        if (!scene) return;
        while(scene.children.length > 0){ 
            scene.remove(scene.children[0]); 
        }
        platforms = [];
        spikes = [];
        walls = [];
        hazards = [];
    }

    function addPlatform(x,y,z,w,h,d,color) {
      const g = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.MeshStandardMaterial({color: color, flatShading: false});
      const mesh = new THREE.Mesh(g,m);
      mesh.receiveShadow = true;
      mesh.castShadow = true;
      mesh.position.set(x,y,z);
      mesh.userData.size = {x:w,y:h,z:d};
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }
    
    function addSpike(x, y, z, color = 0x666666, rotationSpeed = 0, attachedPlatform = null) {
        const spikeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
        const spikeMaterial = new THREE.MeshStandardMaterial({color: color});
        let spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
        spike.castShadow = true;
        spike.receiveShadow = true;
        spike.position.set(x, y, z);
        scene.add(spike);
        
        let hazardObject = {
            mesh: spike, 
            type: 'spike', 
            rotationSpeed: rotationSpeed,
            platform: attachedPlatform // Keep reference for movement
        };
        hazards.push(hazardObject); 
        return hazardObject;
    }


    function createLevel(stage) {
        clearScene();
        
        // --- Lighting ---
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(10, 20, 10);
        dir.castShadow = true;
        dir.shadow.mapSize.set(1024,1024);
        scene.add(dir);
        
        // --- Player Setup ---
        const geom = new THREE.BoxGeometry(1,1,1);
        const mat = new THREE.MeshStandardMaterial({color: currentSettings.playerColor});
        player = new THREE.Mesh(geom, mat);
        player.castShadow = true;
        player.receiveShadow = true;
        player.position.set(0,2,0);
        scene.add(player);
        
        const platformHeight = 0.5;
        const wallMaterial = new THREE.MeshStandardMaterial({color: 0x444444});

        // --- STAGE 1: Wall Jump and Dash Intro ---
        if (stage === 1) {
            addPlatform(0, -1, 0, 20, 1, 20, 0x556b2f); // Floor
            let zPos = 0, yPos = 0;

            // 1. Initial Jump Test
            zPos += 4 + 1.5;
            addPlatform(0, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
            zPos += 5 + 1;

            // 2. Climbing Wall 1 (Intro to Wall Jump)
            yPos += 1.2;
            let plat1 = addPlatform(-5, yPos, zPos, 4, platformHeight, 5, 0x8b4513);
            const tallWallGeometry = new THREE.BoxGeometry(0.5, 8, 8);
            let tallLeftWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
            tallLeftWall.position.set(plat1.position.x - 1.5, plat1.position.y + 4, plat1.position.z);
            scene.add(tallLeftWall); walls.push(tallLeftWall);
            let tallRightWall = new THREE.Mesh(tallWallGeometry, wallMaterial);
            tallRightWall.position.set(plat1.position.x - 3.5, plat1.position.y + 4, plat1.position.z);
            scene.add(tallRightWall); walls.push(tallRightWall);
            
            // Dash jump target 
            zPos += 5 + 2;
            yPos += 2.5;
            addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
            
            // 3. Low Ceiling Dash Section (Hazard 1: Moving Platform Spike)
            yPos += 1;
            zPos += 5 + 1;
            addPlatform(10, yPos, zPos, 6, platformHeight, 3, 0x8b4513);
            addPlatform(10, yPos + 1.5, zPos, 6, 0.2, 3, 0x777777); // Low ceiling

            yPos += 0.5;
            zPos += 5;
            let movingPlat = addPlatform(10, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
            movingPlat.userData.moving = {amplitude:4, speed:0.8, axis:'x', base: movingPlat.position.x};
            addSpike(movingPlat.position.x, movingPlat.position.y + platformHeight/2 + 0.5, movingPlat.position.z, 0x666666, 0, movingPlat); 

            // --- 4. WALL CLIMB TOWER SECTION ---
            const towerHeight = 12; 
            const towerWidth = 5;  
            yPos = movingPlat.position.y + platformHeight/2 + 0.01;
            zPos += 8; 
            let towerEntrance = addPlatform(5, yPos, zPos, 5, platformHeight, 5, 0x8b4513);
            let backWall = new THREE.Mesh(new THREE.BoxGeometry(towerWidth + 2, towerHeight, 0.5), wallMaterial);
            backWall.position.set(towerEntrance.position.x, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z + 2.5);
            scene.add(backWall); walls.push(backWall);
            let leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
            leftWall.position.set(towerEntrance.position.x - (towerWidth/2) - 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
            scene.add(leftWall); walls.push(leftWall);
            let rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, towerHeight, 5), wallMaterial);
            rightWall.position.set(towerEntrance.position.x + (towerWidth/2) + 0.25, towerEntrance.position.y + towerHeight/2, towerEntrance.position.z);
            scene.add(rightWall); walls.push(rightWall);
            yPos += towerHeight + 0.5;
            addPlatform(5, yPos, zPos, 4, platformHeight, 4, 0x556b2f); 

            // --- 5. Final Jump to Win ---
            yPos += 3;
            zPos += 5;
            const winP = addPlatform(5, yPos, zPos, 6, 0.5, 6, 0xffff00);
            winP.userData.win = true;
            
            player.position.set(0,2,0);
        } 
        
        // --- STAGE 2: Rotating Hazards and Precise Jumps ---
        else if (stage === 2) {
            addPlatform(0, -1, 0, 30, 1, 30, 0x556b2f); // Floor
            let zPos = 0, yPos = 0;
            
            // 1. Long Jump
            zPos += 8;
            addPlatform(0, yPos, zPos, 4, platformHeight, 4, 0x8b4513);
            
            // 2. Dash Jump over Rotating Spikes
            yPos += 1;
            zPos += 8;
            addPlatform(0, yPos, zPos, 4, platformHeight, 4, 0x8b4513);
            
            yPos += 1;
            zPos += 8;
            addPlatform(0, yPos, zPos, 4, platformHeight, 4, 0x8b4513);
            
            // Rotating Hazard 1 (A barrier)
            let rotHazard1 = addPlatform(0, yPos + 0.75, zPos, 0.5, 1.5, 8, 0xdd1111);
            rotHazard1.userData.rotating = {speed: 1, axis: 'y'};
            hazards.push({mesh: rotHazard1, type: 'block'});
            
            // 3. Wall Jump Zig Zag
            yPos += 3;
            zPos += 5;
            addPlatform(-5, yPos, zPos, 3, platformHeight, 3, 0x8b4513);
            
            let wall1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 3), wallMaterial);
            wall1.position.set(-6, yPos + 2.5, zPos);
            scene.add(wall1); walls.push(wall1);
            
            yPos += 4;
            addPlatform(5, yPos, zPos, 3, platformHeight, 3, 0x8b4513);
            
            let wall2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 3), wallMaterial);
            wall2.position.set(6, yPos + 2.5, zPos);
            scene.add(wall2); walls.push(wall2);

            // 4. Moving Spikes and Win
            yPos += 3;
            zPos += 5;
            addPlatform(0, yPos, zPos, 8, platformHeight, 8, 0x556b2f);
            
            addSpike(-2, yPos + platformHeight/2 + 0.5, zPos, 0xaa00aa, 3); // Rotating Spike 1
            addSpike(2, yPos + platformHeight/2 + 0.5, zPos, 0xaa00aa, -3); // Rotating Spike 2
            
            yPos += 3;
            zPos += 5;
            const winP = addPlatform(0, yPos, zPos, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
            player.position.set(0,2,0);
        } 
        
        // --- STAGE 3: Final Challenge (Large Wall Climb) ---
        else if (stage === 3) {
            addPlatform(0, -1, 0, 40, 1, 40, 0x556b2f); // Floor
            let zPos = 0, yPos = 0;
            
            // 1. Initial Wall setup
            zPos += 8;
            addPlatform(0, yPos, zPos, 8, platformHeight, 8, 0x8b4513);
            
            const finalWallHeight = 30;
            const finalWallWidth = 15;
            
            let finalBackWall = new THREE.Mesh(new THREE.BoxGeometry(finalWallWidth, finalWallHeight, 0.5), wallMaterial);
            finalBackWall.position.set(0, finalWallHeight/2, zPos + 4.5);
            scene.add(finalBackWall); walls.push(finalBackWall);
            
            let finalLeftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, finalWallHeight, 9), wallMaterial);
            finalLeftWall.position.set(-finalWallWidth/2, finalWallHeight/2, zPos);
            scene.add(finalLeftWall); walls.push(finalLeftWall);
            
            let finalRightWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, finalWallHeight, 9), wallMaterial);
            finalRightWall.position.set(finalWallWidth/2, finalWallHeight/2, zPos);
            scene.add(finalRightWall); walls.push(finalRightWall);
            
            // Platforms for Wall Jump Practice/Aid
            addPlatform(finalWallWidth/2 - 2, 5, zPos + 3, 2, platformHeight, 2, 0x777777);
            addPlatform(-finalWallWidth/2 + 2, 10, zPos + 3, 2, platformHeight, 2, 0x777777);
            addPlatform(finalWallWidth/2 - 2, 15, zPos + 3, 2, platformHeight, 2, 0x777777);
            
            // Moving Platform Gap (Dash needed)
            let movePlat = addPlatform(-7, 20, zPos - 7, 3, platformHeight, 3, 0x1e90ff);
            movePlat.userData.moving = {amplitude: 10, speed: 0.5, axis: 'z', base: movePlat.position.z};
            
            // Rotating Spikes at the top
            yPos = finalWallHeight - 1;
            zPos += 4;
            let topPlat = addPlatform(0, yPos, zPos, 8, platformHeight, 8, 0x556b2f);
            
            addSpike(2, yPos + platformHeight/2 + 0.5, zPos - 2, 0xaa00aa, 2);
            addSpike(-2, yPos + platformHeight/2 + 0.5, zPos + 2, 0xaa00aa, -2);
            
            // Final Win Platform
            yPos += 3;
            zPos += 5;
            const winP = addPlatform(0, yPos, zPos, 4, 0.5, 4, 0xffff00);
            winP.userData.win = true;
            
            player.position.set(0,2,0);
        }
    }

    function init() {
      // 1. Scene Setup (Only done once)
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.getElementById('canvas-holder').appendChild(renderer.domElement);
      
      // 2. Load Level
      createLevel(currentStage);

      // 3. Event Listeners
      window.addEventListener('resize', onWindowResize);
      // NOTE: handleKeyDown is a function declaration, correctly hoisted and available here.
      window.addEventListener('keydown', handleKeyDown); 
      window.addEventListener('keyup', e => keys[e.code] = false);
      renderer.domElement.addEventListener('mousemove', onMouseMove);

      cameraTarget.copy(player.position);
      cameraTarget.y += 0.5;
      
      // 4. Apply initial settings
      applySettings();
    }
    
    // --- Keydown Handler (Error fix: handles R, Esc, and G here) ---
    function handleKeyDown(e) {
        keys[e.code] = true;
        
        // R: Respawn
        if (e.code === 'KeyR' && (gameOver || win || isPaused)) {
            respawn(false);
            e.preventDefault(); 
            return;
        }

        // Esc: Pause/Resume
        if (e.code === 'Escape' && !gameOver && !win) {
            isPaused ? resumeGame() : pauseGame();
            e.preventDefault(); 
            return;
        }
        
        // G: Settings
        if (e.code === 'KeyG' && !gameOver && !win) {
            const settingsPanel = document.getElementById('settingsPanel');
            // Check if settings is currently visible
            if (settingsPanel.style.display === '') {
                closeSettings();
            } else {
                // Determine if we came from the start screen or pause screen
                const fromPause = document.getElementById('pausePanel').style.display === '';
                showSettings(fromPause);
            }
            e.preventDefault(); 
            return;
        }

        if(isPaused || gameOver || win) return;

        // Space: Jump Buffer
        if(e.code === 'Space' || keys['Numpad0']){
          jumpInputBufferTimer = JUMP_INPUT_BUFFER_TIME;
        }

        // Shift: Dash
        if(e.code === 'ShiftLeft' && dashCooldownTimer <= 0 && !isDashing){
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;
            
            let angle = orbitAngleY;
            let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
            let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
            
            dashDirection.set(0,0,0);
            if(dirX !== 0 || dirZ !== 0) {
                dashDirection.addScaledVector(forward, dirZ);
                dashDirection.addScaledVector(right, dirX);
                dashDirection.normalize();
            } else {
                // Default dash direction is forward
                dashDirection.copy(forward);
            }

            isDashing = true;
            dashTimer = DASH_DURATION;
            player.material.color.setHex(dashPlayerColor);
            playSound('dash');
            
            velocity.y = Math.min(velocity.y, 0.5); 
        }
    }


    // --- Animation Logic ---

    function updateAnimations(delta) {
        if (!player || isDashing) return;

        // Player Animation (Squash/Stretch and Rotation)
        let targetScaleY = 1.0;
        let targetScaleXZ = 1.0;
        let targetRotation = 0;
        const speed = 15; // Animation smoothing speed

        const isWallSliding = canWallJump && velocity.y < -0.1;
        const isJumping = !onGround && velocity.y > 0.1;
        const isFalling = !onGround && velocity.y < -0.1 && !isWallSliding;
        
        if (isJumping) {
            targetScaleY = 1.2; 
            targetScaleXZ = 0.8; 
        } else if (isFalling) {
            targetScaleY = 0.8;
            targetScaleXZ = 1.1;
        } else if (onGround) {
            targetScaleY = 1.0;
            targetScaleXZ = 1.0;
        }

        if (isWallSliding) {
            targetScaleY = 1.1; 
            targetScaleXZ = 0.9;
            targetRotation = wallJumpDirection * (Math.PI / 12); // Tilt into the wall
        }

        // Apply smooth transition
        player.scale.y = THREE.MathUtils.lerp(player.scale.y, targetScaleY, delta * speed);
        player.scale.x = THREE.MathUtils.lerp(player.scale.x, targetScaleXZ, delta * speed);
        player.scale.z = THREE.MathUtils.lerp(player.scale.z, targetScaleXZ, delta * speed);
        player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetRotation, delta * speed);
        
        // --- Moving/Rotating Object Animations ---
        const t = clock.getElapsedTime(); 
        
        // Win Platform Rotation
        for (let p of platforms) {
            if (p.userData.win) {
                p.rotation.y += delta * 1.5;
            }
        }
        
        // Rotating Hazards (Spikes or Blocks)
        for (let h of hazards) {
            if (h.rotationSpeed) {
                h.mesh.rotation.y += delta * h.rotationSpeed;
            }
            if (h.type === 'spike' && h.platform && h.platform.userData.moving) {
                // Ensure spike position updates if attached to a moving platform
                h.mesh.position.x = h.platform.position.x;
                h.mesh.position.z = h.platform.position.z;
            } else if (h.type === 'block' && h.mesh.userData.rotating) {
                h.mesh.rotation.y = t * h.mesh.userData.rotating.speed;
            }
        }
    }


    // --- Game Logic Functions ---

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function aabbIntersect(aPos, aSize, bPos, bSize) {
      return Math.abs(aPos.x - bPos.x) <= (aSize.x + bSize.x) &&
             Math.abs(aPos.y - bPos.y) <= (aSize.y + bSize.y) &&
             Math.abs(aPos.z - bPos.z) <= (aSize.z + bSize.z);
    }

    function handleJump(isWallJump, wallDir) {
        if(isWallJump) {
            velocity.y = WALL_JUMP_POWER;
            velocity.x = -8 * wallDir;
            velocity.z = 0; 
            playSound('walljump');
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
            horizontalLockoutTimer = WALL_JUMP_LOCKOUT_TIME; 

        } else {
            velocity.y = JUMP_POWER;
            playSound('jump');
        }
        onGround = false;
        jumpInputBufferTimer = 0;
    }

    function physics(delta) {
        if(gameOver || win || isPaused) return;

        // Update timers
        if (!canWallJump && !onGround) {
            wallJumpCoyoteTimer = Math.max(0, wallJumpCoyoteTimer - delta);
        }
        jumpInputBufferTimer = Math.max(0, jumpInputBufferTimer - delta);
        dashCooldownTimer = Math.max(0, dashCooldownTimer - delta);
        horizontalLockoutTimer = Math.max(0, horizontalLockoutTimer - delta);

        // --- Handle Dash Logic --- 
        if(isDashing) {
            dashTimer -= delta;
            if(dashTimer <= 0) {
                isDashing = false;
                dashCooldownTimer = DASH_COOLDOWN;
                player.material.color.set(currentSettings.playerColor);
                velocity.x *= 0.1; 
                velocity.z *= 0.1;
            } else {
                velocity.x = dashDirection.x * DASH_SPEED;
                velocity.z = dashDirection.z * DASH_SPEED;
                velocity.y = 0; 
            }
        } 
        
        // 1. Horizontal Movement 
        if (!isDashing && horizontalLockoutTimer === 0) { 
            let dirX = 0, dirZ = 0;
            if(keys['KeyW'] || keys['ArrowUp']) dirZ -= 1;
            if(keys['KeyS'] || keys['ArrowDown']) dirZ += 1;
            if(keys['KeyA'] || keys['ArrowLeft']) dirX -= 1;
            if(keys['KeyD'] || keys['ArrowRight']) dirX += 1;

            const speed = 6;
            if(dirX !== 0 || dirZ !== 0) {
                let angle = orbitAngleY;
                let forward = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                let right = new THREE.Vector3(Math.cos(angle), 0, -Math.sin(angle));
                let moveDir = new THREE.Vector3();
                moveDir.addScaledVector(forward, dirZ);
                moveDir.addScaledVector(right, dirX);
                moveDir.normalize();
                
                player.position.addScaledVector(moveDir, speed * delta);
            }
        }
        
        const pPos = player.position.clone();
        const half = {x:0.5,y:0.5,z:0.5};

        
        // 2. Wall detection for wall jump
        let isTouchingWall = false;
        let currentWallDir = 0;

        for(let w of walls){
            const wPos = w.position;
            const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
            if(aabbIntersect(pPos, half, wPos, wSize)){
                let diffX = pPos.x - wPos.x;
                let diffZ = pPos.z - wPos.z;
                
                if (wSize.z < wSize.x) { 
                    if(Math.abs(diffZ) > 0.01){
                        isTouchingWall = true;
                        currentWallDir = diffZ > 0 ? 1 : -1;
                    }
                } else { 
                    if(Math.abs(diffX) > 0.01){
                        isTouchingWall = true;
                        currentWallDir = diffX > 0 ? 1 : -1;
                    }
                }

                if (isTouchingWall) break;
            }
        }

        if (isTouchingWall && !onGround) {
            canWallJump = true;
            wallJumpDirection = currentWallDir;
            wallJumpCoyoteTimer = WALL_JUMP_COYOTE_TIME;
            
            if (velocity.y < 0) {
                velocity.y = Math.max(velocity.y, -1.5);
            }
        } else if (!isTouchingWall && canWallJump) {
            canWallJump = false;
        } else if (onGround) {
            canWallJump = false;
            wallJumpCoyoteTimer = 0;
        }
        
        // 3. Jump Execution
        const isJumpPressed = (keys['Space'] || keys['Numpad0']);
        const canJump = onGround && isJumpPressed;
        const canWallJumpNow = isTouchingWall && jumpInputBufferTimer > 0;
        const canCoyoteJump = wallJumpCoyoteTimer > 0 && isJumpPressed && !onGround && !isTouchingWall;

        if(canJump){
            handleJump(false, 0);
        } else if(canWallJumpNow){
            handleJump(true, currentWallDir);
        } else if(canCoyoteJump){
            handleJump(true, wallJumpDirection); 
        }

        // Apply Gravity
        velocity.y -= 9.8 * delta;

        // Apply velocity X/Z (from wall jump or dash)
        player.position.x += velocity.x * delta;
        
        if (horizontalLockoutTimer === 0) {
             velocity.x *= 0.8; 
        }

        player.position.z += velocity.z * delta; 
        if (horizontalLockoutTimer === 0) {
             velocity.z *= 0.8;
        }


        player.position.y += velocity.y * delta;

        onGround = false;

        // 4. Platform Collision 
        for(let pl of platforms) {
            if(pl.userData.moving){
                const t = clock.getElapsedTime();
                const m = pl.userData.moving;
                if(m.axis === 'x') pl.position.x = m.base + Math.sin(t*m.speed) * m.amplitude;
                else pl.position.z = m.base + Math.sin(t*m.speed) * m.amplitude;
            }
            const size = {x:pl.userData.size.x/2, y:pl.userData.size.y/2, z:pl.userData.size.z/2};
            if(aabbIntersect(player.position, half, pl.position, size)) {
                const playerBottom = player.position.y - half.y; 
                const plTop = pl.position.y + size.y;
                const penetration = plTop - playerBottom;
                if(velocity.y <= 0 && penetration > 0 && Math.abs(player.position.x - pl.position.x) < (size.x+half.x) && Math.abs(player.position.z - pl.position.z) < (size.z+half.z)){
                    player.position.y += penetration + 0.001;
                    velocity.y = 0;
                    onGround = true;
                    
                    if(!pl.userData.moving) {
                       velocity.x = 0;
                       velocity.z = 0;
                    }

                    if(pl.userData.moving){
                        player.position.x += (pl.position.x - (pl.userData._lastX ?? pl.position.x));
                        player.position.z += (pl.position.z - (pl.userData._lastZ ?? pl.position.z));
                    }

                    if(pl.userData.win && !win){
                        win = true;
                        playSound('win');
                        stopMusic();
                        showWin();
                    }
                    
                    canWallJump = false;
                    wallJumpCoyoteTimer = 0;
                    dashCooldownTimer = 0; 
                }
                pl.userData._lastX = pl.position.x;
                pl.userData._lastZ = pl.position.z;
            }
        }

        // 5. Collide with walls
        for(let w of walls){
            const wPos = w.position;
            const wSize = {x:w.geometry.parameters.width/2, y:w.geometry.parameters.height/2, z:w.geometry.parameters.depth/2};
            if(aabbIntersect(player.position, half, wPos, wSize)){
                let diffX = player.position.x - wPos.x;
                let diffZ = player.position.z - wPos.z;
                
                const penX = (wSize.x + half.x) - Math.abs(diffX);
                const penZ = (wSize.z + half.z) - Math.abs(diffZ); 

                if(penX < penZ) {
                    if(diffX > 0){
                        player.position.x += penX + 0.01; 
                        velocity.x = Math.max(velocity.x, 0); 
                    } else {
                        player.position.x -= penX + 0.01;
                        velocity.x = Math.min(velocity.x, 0);
                    }
                } else {
                    if(diffZ > 0){
                        player.position.z += penZ + 0.01;
                        velocity.z = Math.max(velocity.z, 0);
                    } else {
                        player.position.z -= penZ + 0.01;
                        velocity.z = Math.min(velocity.z, 0);
                    }
                }
            }
        }

        // 6. Check hazards collision (game over)
        for(let h of hazards){
            const mesh = h.mesh;
            const hPos = mesh.position.clone();
            
            // For spikes, check distance. For blocks, check AABB.
            if(h.type === 'spike'){
                if(player.position.distanceTo(hPos) < 0.7){
                    triggerGameOver();
                    break;
                }
            } else if (h.type === 'block') {
                const hSize = {x:mesh.userData.size.x/2, y:mesh.userData.size.y/2, z:mesh.userData.size.z/2};
                if(aabbIntersect(player.position, half, hPos, hSize)){
                    triggerGameOver();
                    break;
                }
            }
        }

        // Fall Death
        if(player.position.y < -5){
            triggerGameOver();
        }
    }
    

    function triggerGameOver() {
      if(gameOver) return;
      gameOver = true;
      isPaused = true;
      stopMusic();
      playSound('gameover');
      document.getElementById('gameOverPanel').style.display = '';
      document.getElementById('overlay').style.display = '';
      document.getElementById('gameOverRestartBtn').textContent = `Restart Stage ${currentStage}`;
      hidePanels(['startPanel', 'winPanel', 'pausePanel', 'settingsPanel']);
      document.exitPointerLock();
    }

    function updateCamera() {
      cameraTarget.x = THREE.MathUtils.lerp(cameraTarget.x, player.position.x, CAMERA_SMOOTHING);
      cameraTarget.y = THREE.MathUtils.lerp(cameraTarget.y, player.position.y + 0.5, CAMERA_SMOOTHING);
      cameraTarget.z = THREE.MathUtils.lerp(cameraTarget.z, player.position.z, CAMERA_SMOOTHING);
      
      orbitAngleX = Math.min(Math.max(0.1, orbitAngleX), Math.PI/2 - 0.1);
      
      const x = cameraTarget.x + orbitRadius * Math.cos(orbitAngleX) * Math.sin(orbitAngleY);
      const y = cameraTarget.y + orbitRadius * Math.sin(orbitAngleX);
      const z = cameraTarget.z + orbitRadius * Math.cos(orbitAngleX) * Math.cos(orbitAngleY);
      camera.position.set(x, y, z);
      camera.lookAt(cameraTarget);
    }

    function animate() {
      if (isPaused || gameOver || win) {
        if (animationFrameId !== null) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        return;
      }

      const delta = Math.min(0.05, clock.getDelta());
      physics(delta);
      updateAnimations(delta); 
      updateCamera();
      renderer.render(scene, camera);
      animationFrameId = requestAnimationFrame(animate);
    }

    // --- UI/Pause/Settings Management ---
    
    function hidePanels(panelIds) {
        panelIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
        });
        document.getElementById('overlay').style.display = 'none';
    }

    function showSettings(cameFromPause = false) {
        if (gameOver || win) return;
        
        isPaused = true;
        stopMusic();
        
        hidePanels(['startPanel', 'pausePanel', 'winPanel', 'gameOverPanel']);
        
        document.getElementById('settingsPanel').style.display = '';
        document.getElementById('overlay').style.display = '';
        
        document.getElementById('settingsPanel').dataset.cameFromPause = cameFromPause;
        
        document.exitPointerLock();
    }
    
    function closeSettings() {
        const cameFromPause = document.getElementById('settingsPanel').dataset.cameFromPause === 'true';
        
        document.getElementById('settingsPanel').style.display = 'none';

        if (cameFromPause) {
            pauseGame(true);
        } else {
            document.getElementById('startPanel').style.display = '';
            document.getElementById('overlay').style.display = '';
        }
    }

    function pauseGame(isRevisiting = false) {
        if (isPaused && !isRevisiting) return;
        
        isPaused = true;
        stopMusic();
        
        hidePanels(['startPanel', 'winPanel', 'gameOverPanel', 'settingsPanel']);
        
        document.getElementById('pausePanel').style.display = '';
        document.getElementById('overlay').style.display = '';
        
        if(!isRevisiting) document.exitPointerLock();
    }

    function resumeGame() {
        if (!isPaused) return;
        isPaused = false;
        hidePanels(['startPanel', 'winPanel', 'gameOverPanel', 'pausePanel', 'settingsPanel']);
        
        applySettings(); 
        playMusic();
        
        if (animationFrameId === null) {
            clock.start();
            animate();
        }
        renderer.domElement.requestPointerLock();
    }

    function respawn(nextStage = false) {
        if (nextStage && currentStage < TOTAL_STAGES) {
            currentStage++;
            saveStage();
            
            // Re-initialize the scene for the new level
            createLevel(currentStage);
            
            // Reset orbit camera (so it doesn't try to look at old position)
            orbitAngleX = Math.PI / 4;
            orbitAngleY = 0;
            cameraTarget.copy(player.position);
            cameraTarget.y += 0.5;
            updateCamera();

            // Change button text back to restart
            document.getElementById('gameOverRestartBtn').textContent = `Restart Stage ${currentStage}`;
        } else if (nextStage && currentStage === TOTAL_STAGES) {
             // Game Completed
             document.getElementById('winTitle').textContent = "Game Complete! You beat all stages! üéâ";
             document.getElementById('restartBtn').textContent = "Start Over (Stage 1)";
             currentStage = 1; // Prepare for a new game
             saveStage();
             return; // Don't call resume, stay on the win screen
        }

        player.position.set(0, 2, 0); 
        velocity.set(0,0,0);
        win = false;
        gameOver = false;
        isPaused = false;
        
        // Reset player animations/appearance
        player.scale.set(1,1,1);
        player.rotation.set(0,0,0);
        player.material.color.set(currentSettings.playerColor);
        
        // Reset state variables
        canWallJump = false;
        wallJumpDirection = 0;
        wallJumpCoyoteTimer = 0;
        jumpInputBufferTimer = 0;
        isDashing = false;
        dashCooldownTimer = 0;
        horizontalLockoutTimer = 0; 
      
        hidePanels(['startPanel', 'winPanel', 'gameOverPanel', 'pausePanel', 'settingsPanel']);

        clock.start();
        playMusic();
        animate();
        renderer.domElement.requestPointerLock();
    }

    function showWin() {
        isPaused = true;
        stopMusic();
        
        const isGameComplete = currentStage === TOTAL_STAGES;
        
        if (isGameComplete) {
            document.getElementById('winTitle').textContent = "Game Complete! You beat all stages! üéâ";
            document.getElementById('restartBtn').textContent = "Start Over (Stage 1)";
        } else {
            document.getElementById('winTitle').textContent = `Stage ${currentStage} Complete!`;
            document.getElementById('restartBtn').textContent = `Play Next Stage (${currentStage + 1})`;
        }
        
        document.getElementById('winPanel').style.display = '';
        document.getElementById('overlay').style.display = '';
        hidePanels(['startPanel', 'gameOverPanel', 'pausePanel', 'settingsPanel']);
        document.exitPointerLock();
    }

    function onMouseMove(e) {
      if (isPaused || gameOver || win) return;
      
      let deltaX = e.movementX;
      let deltaY = e.movementY;

      if (deltaX === undefined || deltaY === undefined) return; 
      
      orbitAngleY -= deltaX * dragSensitivity;
      orbitAngleX -= deltaY * dragSensitivity;
    }

    // --- Initialization and Event Wiring ---

    window.addEventListener('DOMContentLoaded', () => {
      // 1. Load Settings and Init Game
      loadSettings();
      audioCtx = new AudioContext();
      init();

      // 2. Wire UI Buttons
      document.getElementById('startBtn').addEventListener('click', () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        respawn(false); // Start the current stage
      });
      document.getElementById('resumeBtn').addEventListener('click', resumeGame);
      document.getElementById('pauseRestartBtn').addEventListener('click', () => respawn(false));
      document.getElementById('gameOverRestartBtn').addEventListener('click', () => respawn(false));
      
      // The main 'Win' button handles both next stage and starting over
      document.getElementById('restartBtn').addEventListener('click', () => {
          respawn(true); // Argument 'true' means advance to next stage (or restart game)
      });
      
      // Settings Buttons
      document.getElementById('showSettingsBtn').addEventListener('click', () => showSettings(false));
      document.getElementById('pauseSettingsBtn').addEventListener('click', () => showSettings(true));
      document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);

      // 3. Wire Setting Controls
      const volumeRange = document.getElementById('volumeRange');
      volumeRange.addEventListener('input', () => {
        currentSettings.volume = volumeRange.value / 100;
        applySettings();
        saveSettings();
      });

      const playerColorPicker = document.getElementById('playerColorPicker');
      playerColorPicker.addEventListener('input', () => {
        currentSettings.playerColor = playerColorPicker.value;
        applySettings();
        saveSettings();
      });
      
      const cameraDistanceRange = document.getElementById('cameraDistanceRange');
      const cameraDistanceValue = document.getElementById('cameraDistanceValue');
      cameraDistanceRange.addEventListener('input', () => {
        currentSettings.cameraDistance = parseFloat(cameraDistanceRange.value);
        cameraDistanceValue.textContent = currentSettings.cameraDistance.toFixed(0) + 'm';
        applySettings();
        saveSettings();
      });
      
      // 4. Pointer Lock Check (for auto-pause)
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement !== renderer.domElement && !gameOver && !win && !isPaused) {
          pauseGame();
        }
      });
    });
</script>
</body>
</html>
